// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(MatrixSDKCryptoFFI)
import MatrixSDKCryptoFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_olm_c9b9_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_olm_c9b9_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a libray of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// A helper class to read values out of a byte buffer.
fileprivate class Reader {
    let data: Data
    var offset: Data.Index

    init(data: Data) {
        self.data = data
        self.offset = 0
    }

    // Reads an integer at the current offset, in big-endian order, and advances
    // the offset on success. Throws if reading the integer would move the
    // offset past the end of the buffer.
    func readInt<T: FixedWidthInteger>() throws -> T {
        let range = offset..<offset + MemoryLayout<T>.size
        guard data.count >= range.upperBound else {
            throw UniffiInternalError.bufferOverflow
        }
        if T.self == UInt8.self {
            let value = data[offset]
            offset += 1
            return value as! T
        }
        var value: T = 0
        let _ = withUnsafeMutableBytes(of: &value, { data.copyBytes(to: $0, from: range)})
        offset = range.upperBound
        return value.bigEndian
    }

    // Reads an arbitrary number of bytes, to be used to read
    // raw bytes, this is useful when lifting strings
    func readBytes(count: Int) throws -> Array<UInt8> {
        let range = offset..<(offset+count)
        guard data.count >= range.upperBound else {
            throw UniffiInternalError.bufferOverflow
        }
        var value = [UInt8](repeating: 0, count: count)
        value.withUnsafeMutableBufferPointer({ buffer in
            data.copyBytes(to: buffer, from: range)
        })
        offset = range.upperBound
        return value
    }

    // Reads a float at the current offset.
    @inlinable
    func readFloat() throws -> Float {
        return Float(bitPattern: try readInt())
    }

    // Reads a float at the current offset.
    @inlinable
    func readDouble() throws -> Double {
        return Double(bitPattern: try readInt())
    }

    // Indicates if the offset has reached the end of the buffer.
    @inlinable
    func hasRemaining() -> Bool {
        return offset < data.count
    }
}

// A helper class to write values into a byte buffer.
fileprivate class Writer {
    var bytes: [UInt8]
    var offset: Array<UInt8>.Index

    init() {
        self.bytes = []
        self.offset = 0
    }

    func writeBytes<S>(_ byteArr: S) where S: Sequence, S.Element == UInt8 {
        bytes.append(contentsOf: byteArr)
    }

    // Writes an integer in big-endian order.
    //
    // Warning: make sure what you are trying to write
    // is in the correct type!
    func writeInt<T: FixedWidthInteger>(_ value: T) {
        var value = value.bigEndian
        withUnsafeBytes(of: &value) { bytes.append(contentsOf: $0) }
    }

    @inlinable
    func writeFloat(_ value: Float) {
        writeInt(value.bitPattern)
    }

    @inlinable
    func writeDouble(_ value: Double) {
        writeInt(value.bitPattern)
    }
}


// Types conforming to `Serializable` can be read and written in a bytebuffer.
fileprivate protocol Serializable {
    func write(into: Writer)
    static func read(from: Reader) throws -> Self
}

// Types confirming to `ViaFfi` can be transferred back-and-for over the FFI.
// This is analogous to the Rust trait of the same name.
fileprivate protocol ViaFfi: Serializable {
    associatedtype FfiType
    static func lift(_ v: FfiType) throws -> Self
    func lower() -> FfiType
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol Primitive {}

extension Primitive {
    fileprivate typealias FfiType = Self

    fileprivate static func lift(_ v: Self) throws -> Self {
        return v
    }

    fileprivate func lower() -> Self {
        return self
    }
}

// Types conforming to `ViaFfiUsingByteBuffer` lift and lower into a bytebuffer.
// Use this for complex types where it's hard to write a custom lift/lower.
fileprivate protocol ViaFfiUsingByteBuffer: Serializable {}

extension ViaFfiUsingByteBuffer {
    fileprivate typealias FfiType = RustBuffer

    fileprivate static func lift(_ buf: FfiType) throws -> Self {
      let reader = Reader(data: Data(rustBuffer: buf))
      let value = try Self.read(from: reader)
      if reader.hasRemaining() {
          throw UniffiInternalError.incompleteData
      }
      buf.deallocate()
      return value
    }

    fileprivate func lower() -> FfiType {
      let writer = Writer()
      self.write(into: writer)
      return RustBuffer(bytes: writer.bytes)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: {
        $0.deallocate()
        return UniffiInternalError.unexpectedRustCallError
    })
}

private func rustCallWithError<T, E: ViaFfiUsingByteBuffer & Error>(_ errorClass: E.Type, _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: { return try E.lift($0) })
}

private func makeRustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T, errorHandler: (RustBuffer) throws -> Error) throws -> T {
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    switch callStatus.code {
        case CALL_SUCCESS:
            return returnedVal

        case CALL_ERROR:
            throw try errorHandler(callStatus.errorBuf)

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try String.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}
// Protocols for converters we'll implement in templates

fileprivate protocol FfiConverter {
    associatedtype SwiftType
    associatedtype FfiType

    static func lift(_ ffiValue: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType

    static func read(from: Reader) throws -> SwiftType
    static func write(_ value: SwiftType, into: Writer)
}

fileprivate protocol FfiConverterUsingByteBuffer: FfiConverter where FfiType == RustBuffer {
    // Empty, because we want to declare some helper methods in the extension below.
}

extension FfiConverterUsingByteBuffer {
    static func lower(_ value: SwiftType) -> FfiType {
        let writer = Writer()
        Self.write(value, into: writer)
        return RustBuffer(bytes: writer.bytes)
    }

    static func lift(_ buf: FfiType) throws -> SwiftType {
        let reader = Reader(data: Data(rustBuffer: buf))
        let value = try Self.read(from: reader)
        if reader.hasRemaining() {
          throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }
}

// Helpers for structural types. Note that because of canonical_names, it /should/ be impossible
// to make another `FfiConverterSequence` etc just using the UDL.
fileprivate enum FfiConverterSequence {
    static func write<T>(_ value: [T], into buf: Writer, writeItem: (T, Writer) -> Void) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            writeItem(item, buf)
        }
    }

    static func read<T>(from buf: Reader, readItem: (Reader) throws -> T) throws -> [T] {
        let len: Int32 = try buf.readInt()
        var seq = [T]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try readItem(buf))
        }
        return seq
    }
}

fileprivate enum FfiConverterOptional {
    static func write<T>(_ value: T?, into buf: Writer, writeItem: (T, Writer) -> Void) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        writeItem(value, buf)
    }

    static func read<T>(from buf: Reader, readItem: (Reader) throws -> T) throws -> T? {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try readItem(buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate enum FfiConverterDictionary {
    static func write<T>(_ value: [String: T], into buf: Writer, writeItem: (String, T, Writer) -> Void) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for (key, value) in value {
            writeItem(key, value, buf)
        }
    }

    static func read<T>(from buf: Reader, readItem: (Reader) throws -> (String, T)) throws -> [String: T] {
        let len: Int32 = try buf.readInt()
        var dict = [String: T]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let (key, value) = try readItem(buf)
            dict[key] = value
        }
        return dict
    }
}

// Public interface members begin here.


fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate typealias Handle = UInt64
fileprivate class ConcurrentHandleMap<T> {
    private var leftMap: [Handle: T] = [:]
    private var counter: [Handle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: Handle] = [:]

    private let lock = NSLock()
    private var currentHandle: Handle = 0
    private let stride: Handle = 1

    func insert(obj: T) -> Handle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: Handle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: Handle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: Handle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0

fileprivate class FfiConverterCallbackInterface<CallbackInterface> {
    fileprivate let handleMap = ConcurrentHandleMap<CallbackInterface>()

    func drop(handle: Handle) {
        handleMap.remove(handle: handle)
    }

    func lift(_ handle: Handle) throws -> CallbackInterface {
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    func read(from buf: Reader) throws -> CallbackInterface {
        let handle: Handle = try buf.readInt()
        return try lift(handle)
    }

    func lower(_ v: CallbackInterface) -> Handle {
        let handle = handleMap.insert(obj: v)
        return handle
        // assert(handleMap.get(handle: obj) == v, "Handle map is not returning the object we just placed there. This is a bug in the HandleMap.")
    }

    func write(_ v: CallbackInterface, into buf: Writer) {
        buf.writeInt(lower(v))
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum UserIdentity {
    
    case own(userId: String, trustsOurOwnDevice: Bool, masterKey: String, selfSigningKey: String, userSigningKey: String )
    case other(userId: String, masterKey: String, selfSigningKey: String )
}

extension UserIdentity: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> UserIdentity {
        let variant: Int32 = try buf.readInt()
        switch variant {
        
        case 1: return .own(
            userId: try String.read(from: buf),
            trustsOurOwnDevice: try Bool.read(from: buf),
            masterKey: try String.read(from: buf),
            selfSigningKey: try String.read(from: buf),
            userSigningKey: try String.read(from: buf)
            )
        case 2: return .other(
            userId: try String.read(from: buf),
            masterKey: try String.read(from: buf),
            selfSigningKey: try String.read(from: buf)
            )
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        
        
        case let .own(userId,trustsOurOwnDevice,masterKey,selfSigningKey,userSigningKey):
            buf.writeInt(Int32(1))
            userId.write(into: buf)
            trustsOurOwnDevice.write(into: buf)
            masterKey.write(into: buf)
            selfSigningKey.write(into: buf)
            userSigningKey.write(into: buf)
            
        
        
        case let .other(userId,masterKey,selfSigningKey):
            buf.writeInt(Int32(2))
            userId.write(into: buf)
            masterKey.write(into: buf)
            selfSigningKey.write(into: buf)
            
        
        }
    }
}


extension UserIdentity: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Verification {
    
    case sasV1(sas: Sas )
    case qrCodeV1(qrcode: QrCode )
}

extension Verification: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Verification {
        let variant: Int32 = try buf.readInt()
        switch variant {
        
        case 1: return .sasV1(
            sas: try Sas.read(from: buf)
            )
        case 2: return .qrCodeV1(
            qrcode: try QrCode.read(from: buf)
            )
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        
        
        case let .sasV1(sas):
            buf.writeInt(Int32(1))
            sas.write(into: buf)
            
        
        
        case let .qrCodeV1(qrcode):
            buf.writeInt(Int32(2))
            qrcode.write(into: buf)
            
        
        }
    }
}


extension Verification: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum OutgoingVerificationRequest {
    
    case toDevice(requestId: String, eventType: String, body: String )
    case inRoom(requestId: String, roomId: String, eventType: String, content: String )
}

extension OutgoingVerificationRequest: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> OutgoingVerificationRequest {
        let variant: Int32 = try buf.readInt()
        switch variant {
        
        case 1: return .toDevice(
            requestId: try String.read(from: buf),
            eventType: try String.read(from: buf),
            body: try String.read(from: buf)
            )
        case 2: return .inRoom(
            requestId: try String.read(from: buf),
            roomId: try String.read(from: buf),
            eventType: try String.read(from: buf),
            content: try String.read(from: buf)
            )
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        
        
        case let .toDevice(requestId,eventType,body):
            buf.writeInt(Int32(1))
            requestId.write(into: buf)
            eventType.write(into: buf)
            body.write(into: buf)
            
        
        
        case let .inRoom(requestId,roomId,eventType,content):
            buf.writeInt(Int32(2))
            requestId.write(into: buf)
            roomId.write(into: buf)
            eventType.write(into: buf)
            content.write(into: buf)
            
        
        }
    }
}


extension OutgoingVerificationRequest: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Request {
    
    case toDevice(requestId: String, eventType: String, body: String )
    case keysUpload(requestId: String, body: String )
    case keysQuery(requestId: String, users: [String] )
    case keysClaim(requestId: String, oneTimeKeys: [String: [String: String]] )
    case keysBackup(requestId: String, version: String, rooms: String )
    case roomMessage(requestId: String, roomId: String, eventType: String, content: String )
    case signatureUpload(requestId: String, body: String )
}

extension Request: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Request {
        let variant: Int32 = try buf.readInt()
        switch variant {
        
        case 1: return .toDevice(
            requestId: try String.read(from: buf),
            eventType: try String.read(from: buf),
            body: try String.read(from: buf)
            )
        case 2: return .keysUpload(
            requestId: try String.read(from: buf),
            body: try String.read(from: buf)
            )
        case 3: return .keysQuery(
            requestId: try String.read(from: buf),
            users: try FfiConverterSequenceString.read(from: buf)
            )
        case 4: return .keysClaim(
            requestId: try String.read(from: buf),
            oneTimeKeys: try FfiConverterDictionaryDictionaryString.read(from: buf)
            )
        case 5: return .keysBackup(
            requestId: try String.read(from: buf),
            version: try String.read(from: buf),
            rooms: try String.read(from: buf)
            )
        case 6: return .roomMessage(
            requestId: try String.read(from: buf),
            roomId: try String.read(from: buf),
            eventType: try String.read(from: buf),
            content: try String.read(from: buf)
            )
        case 7: return .signatureUpload(
            requestId: try String.read(from: buf),
            body: try String.read(from: buf)
            )
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        
        
        case let .toDevice(requestId,eventType,body):
            buf.writeInt(Int32(1))
            requestId.write(into: buf)
            eventType.write(into: buf)
            body.write(into: buf)
            
        
        
        case let .keysUpload(requestId,body):
            buf.writeInt(Int32(2))
            requestId.write(into: buf)
            body.write(into: buf)
            
        
        
        case let .keysQuery(requestId,users):
            buf.writeInt(Int32(3))
            requestId.write(into: buf)
            FfiConverterSequenceString.write(users, into: buf)
            
        
        
        case let .keysClaim(requestId,oneTimeKeys):
            buf.writeInt(Int32(4))
            requestId.write(into: buf)
            FfiConverterDictionaryDictionaryString.write(oneTimeKeys, into: buf)
            
        
        
        case let .keysBackup(requestId,version,rooms):
            buf.writeInt(Int32(5))
            requestId.write(into: buf)
            version.write(into: buf)
            rooms.write(into: buf)
            
        
        
        case let .roomMessage(requestId,roomId,eventType,content):
            buf.writeInt(Int32(6))
            requestId.write(into: buf)
            roomId.write(into: buf)
            eventType.write(into: buf)
            content.write(into: buf)
            
        
        
        case let .signatureUpload(requestId,body):
            buf.writeInt(Int32(7))
            requestId.write(into: buf)
            body.write(into: buf)
            
        
        }
    }
}


extension Request: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RequestType {
    
    case keysQuery
    case keysClaim
    case keysUpload
    case toDevice
    case signatureUpload
    case keysBackup
    case roomMessage
}

extension RequestType: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> RequestType {
        let variant: Int32 = try buf.readInt()
        switch variant {
        
        case 1: return .keysQuery
        case 2: return .keysClaim
        case 3: return .keysUpload
        case 4: return .toDevice
        case 5: return .signatureUpload
        case 6: return .keysBackup
        case 7: return .roomMessage
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        
        
        case .keysQuery:
            buf.writeInt(Int32(1))
        
        
        case .keysClaim:
            buf.writeInt(Int32(2))
        
        
        case .keysUpload:
            buf.writeInt(Int32(3))
        
        
        case .toDevice:
            buf.writeInt(Int32(4))
        
        
        case .signatureUpload:
            buf.writeInt(Int32(5))
        
        
        case .keysBackup:
            buf.writeInt(Int32(6))
        
        
        case .roomMessage:
            buf.writeInt(Int32(7))
        
        }
    }
}


extension RequestType: Equatable, Hashable {}



public func setLogger( logger: Logger )  {
    try!
    
    
    rustCall() {
    
    olm_c9b9_set_logger(ffiConverterCallbackInterfaceLogger.lower(logger) , $0)
}
}



public func migrate( data: MigrationData,  path: String,  passphrase: String?,  progressListener: ProgressListener ) throws {
    try
    
    
    rustCallWithError(MigrationError.self) {
    
    olm_c9b9_migrate(data.lower(), path.lower(), FfiConverterOptionString.lower(passphrase), ffiConverterCallbackInterfaceProgressListener.lower(progressListener) , $0)
}
}



public protocol OlmMachineProtocol {
    func identityKeys()  -> [String: String]
    func userId()  -> String
    func deviceId()  -> String
    func receiveSyncChanges( events: String,  deviceChanges: DeviceLists,  keyCounts: [String: Int32],  unusedFallbackKeys: [String]? ) throws -> String
    func outgoingRequests() throws -> [Request]
    func markRequestAsSent( requestId: String,  requestType: RequestType,  response: String ) throws
    func decryptRoomEvent( event: String,  roomId: String ) throws -> DecryptedEvent
    func encrypt( roomId: String,  eventType: String,  content: String ) throws -> String
    func getIdentity( userId: String,  timeout: UInt32 ) throws -> UserIdentity?
    func verifyIdentity( userId: String ) throws -> SignatureUploadRequest
    func getDevice( userId: String,  deviceId: String,  timeout: UInt32 ) throws -> Device?
    func markDeviceAsTrusted( userId: String,  deviceId: String ) throws
    func verifyDevice( userId: String,  deviceId: String ) throws -> SignatureUploadRequest
    func getUserDevices( userId: String,  timeout: UInt32 ) throws -> [Device]
    func isUserTracked( userId: String ) throws -> Bool
    func updateTrackedUsers( users: [String] ) 
    func getMissingSessions( users: [String] ) throws -> Request?
    func shareRoomKey( roomId: String,  users: [String] ) throws -> [Request]
    func receiveUnencryptedVerificationEvent( event: String,  roomId: String ) throws
    func getVerificationRequests( userId: String )  -> [VerificationRequest]
    func getVerificationRequest( userId: String,  flowId: String )  -> VerificationRequest?
    func getVerification( userId: String,  flowId: String )  -> Verification?
    func requestVerification( userId: String,  roomId: String,  eventId: String,  methods: [String] ) throws -> VerificationRequest?
    func verificationRequestContent( userId: String,  methods: [String] ) throws -> String?
    func requestSelfVerification( methods: [String] ) throws -> RequestVerificationResult?
    func requestVerificationWithDevice( userId: String,  deviceId: String,  methods: [String] ) throws -> RequestVerificationResult?
    func acceptVerificationRequest( userId: String,  flowId: String,  methods: [String] )  -> OutgoingVerificationRequest?
    func confirmVerification( userId: String,  flowId: String ) throws -> ConfirmVerificationResult?
    func cancelVerification( userId: String,  flowId: String,  cancelCode: String )  -> OutgoingVerificationRequest?
    func startSasWithDevice( userId: String,  deviceId: String ) throws -> StartSasResult?
    func startSasVerification( userId: String,  flowId: String ) throws -> StartSasResult?
    func acceptSasVerification( userId: String,  flowId: String )  -> OutgoingVerificationRequest?
    func getEmojiIndex( userId: String,  flowId: String )  -> [Int32]?
    func getDecimals( userId: String,  flowId: String )  -> [Int32]?
    func startQrVerification( userId: String,  flowId: String ) throws -> QrCode?
    func scanQrCode( userId: String,  flowId: String,  data: String )  -> ScanResult?
    func generateQrCode( userId: String,  flowId: String )  -> String?
    func requestRoomKey( event: String,  roomId: String ) throws -> KeyRequestPair
    func exportKeys( passphrase: String,  rounds: Int32 ) throws -> String
    func importKeys( keys: String,  passphrase: String,  progressListener: ProgressListener ) throws -> KeysImportResult
    func importDecryptedKeys( keys: String,  progressListener: ProgressListener ) throws -> KeysImportResult
    func discardRoomKey( roomId: String ) throws
    func crossSigningStatus()  -> CrossSigningStatus
    func bootstrapCrossSigning() throws -> BootstrapCrossSigningResult
    func exportCrossSigningKeys()  -> CrossSigningKeyExport?
    func importCrossSigningKeys( export: CrossSigningKeyExport ) throws
    func isIdentityVerified( userId: String ) throws -> Bool
    func sign( message: String )  -> [String: [String: String]]
    func enableBackupV1( key: MegolmV1BackupKey,  version: String ) throws
    func disableBackup() throws
    func backupRoomKeys() throws -> Request?
    func saveRecoveryKey( key: BackupRecoveryKey?,  version: String? ) throws
    func roomKeyCounts() throws -> RoomKeyCounts
    func getBackupKeys() throws -> BackupKeys?
    func backupEnabled()  -> Bool
    func verifyBackup( authData: String ) throws -> Bool
    
}

public class OlmMachine: OlmMachineProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `ViaFfi` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init( userId: String,  deviceId: String,  path: String,  passphrase: String? ) throws {
        self.init(unsafeFromRawPointer: try
    
    
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_new(userId.lower(), deviceId.lower(), path.lower(), FfiConverterOptionString.lower(passphrase) , $0)
})
    }

    deinit {
        try! rustCall { ffi_olm_c9b9_OlmMachine_object_free(pointer, $0) }
    }

    

    
    public func identityKeys()  -> [String: String] {
        let _retval = try!
    rustCall() {
    
    olm_c9b9_OlmMachine_identity_keys(self.pointer,  $0
    )
}
        return try! FfiConverterDictionaryString.lift(_retval)
    }
    public func userId()  -> String {
        let _retval = try!
    rustCall() {
    
    olm_c9b9_OlmMachine_user_id(self.pointer,  $0
    )
}
        return try! String.lift(_retval)
    }
    public func deviceId()  -> String {
        let _retval = try!
    rustCall() {
    
    olm_c9b9_OlmMachine_device_id(self.pointer,  $0
    )
}
        return try! String.lift(_retval)
    }
    public func receiveSyncChanges( events: String,  deviceChanges: DeviceLists,  keyCounts: [String: Int32],  unusedFallbackKeys: [String]? ) throws -> String {
        let _retval = try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_receive_sync_changes(self.pointer, events.lower(), deviceChanges.lower(), FfiConverterDictionaryInt32.lower(keyCounts), FfiConverterOptionSequenceString.lower(unusedFallbackKeys) , $0
    )
}
        return try String.lift(_retval)
    }
    public func outgoingRequests() throws -> [Request] {
        let _retval = try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_outgoing_requests(self.pointer,  $0
    )
}
        return try FfiConverterSequenceEnumRequest.lift(_retval)
    }
    public func markRequestAsSent( requestId: String,  requestType: RequestType,  response: String ) throws {
        try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_mark_request_as_sent(self.pointer, requestId.lower(), requestType.lower(), response.lower() , $0
    )
}
    }
    public func decryptRoomEvent( event: String,  roomId: String ) throws -> DecryptedEvent {
        let _retval = try
    rustCallWithError(DecryptionError.self) {
    
    olm_c9b9_OlmMachine_decrypt_room_event(self.pointer, event.lower(), roomId.lower() , $0
    )
}
        return try DecryptedEvent.lift(_retval)
    }
    public func encrypt( roomId: String,  eventType: String,  content: String ) throws -> String {
        let _retval = try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_encrypt(self.pointer, roomId.lower(), eventType.lower(), content.lower() , $0
    )
}
        return try String.lift(_retval)
    }
    public func getIdentity( userId: String,  timeout: UInt32 ) throws -> UserIdentity? {
        let _retval = try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_get_identity(self.pointer, userId.lower(), timeout.lower() , $0
    )
}
        return try FfiConverterOptionEnumUserIdentity.lift(_retval)
    }
    public func verifyIdentity( userId: String ) throws -> SignatureUploadRequest {
        let _retval = try
    rustCallWithError(SignatureError.self) {
    
    olm_c9b9_OlmMachine_verify_identity(self.pointer, userId.lower() , $0
    )
}
        return try SignatureUploadRequest.lift(_retval)
    }
    public func getDevice( userId: String,  deviceId: String,  timeout: UInt32 ) throws -> Device? {
        let _retval = try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_get_device(self.pointer, userId.lower(), deviceId.lower(), timeout.lower() , $0
    )
}
        return try FfiConverterOptionRecordDevice.lift(_retval)
    }
    public func markDeviceAsTrusted( userId: String,  deviceId: String ) throws {
        try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_mark_device_as_trusted(self.pointer, userId.lower(), deviceId.lower() , $0
    )
}
    }
    public func verifyDevice( userId: String,  deviceId: String ) throws -> SignatureUploadRequest {
        let _retval = try
    rustCallWithError(SignatureError.self) {
    
    olm_c9b9_OlmMachine_verify_device(self.pointer, userId.lower(), deviceId.lower() , $0
    )
}
        return try SignatureUploadRequest.lift(_retval)
    }
    public func getUserDevices( userId: String,  timeout: UInt32 ) throws -> [Device] {
        let _retval = try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_get_user_devices(self.pointer, userId.lower(), timeout.lower() , $0
    )
}
        return try FfiConverterSequenceRecordDevice.lift(_retval)
    }
    public func isUserTracked( userId: String ) throws -> Bool {
        let _retval = try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_is_user_tracked(self.pointer, userId.lower() , $0
    )
}
        return try Bool.lift(_retval)
    }
    public func updateTrackedUsers( users: [String] )  {
        try!
    rustCall() {
    
    olm_c9b9_OlmMachine_update_tracked_users(self.pointer, FfiConverterSequenceString.lower(users) , $0
    )
}
    }
    public func getMissingSessions( users: [String] ) throws -> Request? {
        let _retval = try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_get_missing_sessions(self.pointer, FfiConverterSequenceString.lower(users) , $0
    )
}
        return try FfiConverterOptionEnumRequest.lift(_retval)
    }
    public func shareRoomKey( roomId: String,  users: [String] ) throws -> [Request] {
        let _retval = try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_share_room_key(self.pointer, roomId.lower(), FfiConverterSequenceString.lower(users) , $0
    )
}
        return try FfiConverterSequenceEnumRequest.lift(_retval)
    }
    public func receiveUnencryptedVerificationEvent( event: String,  roomId: String ) throws {
        try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_receive_unencrypted_verification_event(self.pointer, event.lower(), roomId.lower() , $0
    )
}
    }
    public func getVerificationRequests( userId: String )  -> [VerificationRequest] {
        let _retval = try!
    rustCall() {
    
    olm_c9b9_OlmMachine_get_verification_requests(self.pointer, userId.lower() , $0
    )
}
        return try! FfiConverterSequenceRecordVerificationRequest.lift(_retval)
    }
    public func getVerificationRequest( userId: String,  flowId: String )  -> VerificationRequest? {
        let _retval = try!
    rustCall() {
    
    olm_c9b9_OlmMachine_get_verification_request(self.pointer, userId.lower(), flowId.lower() , $0
    )
}
        return try! FfiConverterOptionRecordVerificationRequest.lift(_retval)
    }
    public func getVerification( userId: String,  flowId: String )  -> Verification? {
        let _retval = try!
    rustCall() {
    
    olm_c9b9_OlmMachine_get_verification(self.pointer, userId.lower(), flowId.lower() , $0
    )
}
        return try! FfiConverterOptionEnumVerification.lift(_retval)
    }
    public func requestVerification( userId: String,  roomId: String,  eventId: String,  methods: [String] ) throws -> VerificationRequest? {
        let _retval = try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_request_verification(self.pointer, userId.lower(), roomId.lower(), eventId.lower(), FfiConverterSequenceString.lower(methods) , $0
    )
}
        return try FfiConverterOptionRecordVerificationRequest.lift(_retval)
    }
    public func verificationRequestContent( userId: String,  methods: [String] ) throws -> String? {
        let _retval = try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_verification_request_content(self.pointer, userId.lower(), FfiConverterSequenceString.lower(methods) , $0
    )
}
        return try FfiConverterOptionString.lift(_retval)
    }
    public func requestSelfVerification( methods: [String] ) throws -> RequestVerificationResult? {
        let _retval = try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_request_self_verification(self.pointer, FfiConverterSequenceString.lower(methods) , $0
    )
}
        return try FfiConverterOptionRecordRequestVerificationResult.lift(_retval)
    }
    public func requestVerificationWithDevice( userId: String,  deviceId: String,  methods: [String] ) throws -> RequestVerificationResult? {
        let _retval = try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_request_verification_with_device(self.pointer, userId.lower(), deviceId.lower(), FfiConverterSequenceString.lower(methods) , $0
    )
}
        return try FfiConverterOptionRecordRequestVerificationResult.lift(_retval)
    }
    public func acceptVerificationRequest( userId: String,  flowId: String,  methods: [String] )  -> OutgoingVerificationRequest? {
        let _retval = try!
    rustCall() {
    
    olm_c9b9_OlmMachine_accept_verification_request(self.pointer, userId.lower(), flowId.lower(), FfiConverterSequenceString.lower(methods) , $0
    )
}
        return try! FfiConverterOptionEnumOutgoingVerificationRequest.lift(_retval)
    }
    public func confirmVerification( userId: String,  flowId: String ) throws -> ConfirmVerificationResult? {
        let _retval = try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_confirm_verification(self.pointer, userId.lower(), flowId.lower() , $0
    )
}
        return try FfiConverterOptionRecordConfirmVerificationResult.lift(_retval)
    }
    public func cancelVerification( userId: String,  flowId: String,  cancelCode: String )  -> OutgoingVerificationRequest? {
        let _retval = try!
    rustCall() {
    
    olm_c9b9_OlmMachine_cancel_verification(self.pointer, userId.lower(), flowId.lower(), cancelCode.lower() , $0
    )
}
        return try! FfiConverterOptionEnumOutgoingVerificationRequest.lift(_retval)
    }
    public func startSasWithDevice( userId: String,  deviceId: String ) throws -> StartSasResult? {
        let _retval = try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_start_sas_with_device(self.pointer, userId.lower(), deviceId.lower() , $0
    )
}
        return try FfiConverterOptionRecordStartSasResult.lift(_retval)
    }
    public func startSasVerification( userId: String,  flowId: String ) throws -> StartSasResult? {
        let _retval = try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_start_sas_verification(self.pointer, userId.lower(), flowId.lower() , $0
    )
}
        return try FfiConverterOptionRecordStartSasResult.lift(_retval)
    }
    public func acceptSasVerification( userId: String,  flowId: String )  -> OutgoingVerificationRequest? {
        let _retval = try!
    rustCall() {
    
    olm_c9b9_OlmMachine_accept_sas_verification(self.pointer, userId.lower(), flowId.lower() , $0
    )
}
        return try! FfiConverterOptionEnumOutgoingVerificationRequest.lift(_retval)
    }
    public func getEmojiIndex( userId: String,  flowId: String )  -> [Int32]? {
        let _retval = try!
    rustCall() {
    
    olm_c9b9_OlmMachine_get_emoji_index(self.pointer, userId.lower(), flowId.lower() , $0
    )
}
        return try! FfiConverterOptionSequenceInt32.lift(_retval)
    }
    public func getDecimals( userId: String,  flowId: String )  -> [Int32]? {
        let _retval = try!
    rustCall() {
    
    olm_c9b9_OlmMachine_get_decimals(self.pointer, userId.lower(), flowId.lower() , $0
    )
}
        return try! FfiConverterOptionSequenceInt32.lift(_retval)
    }
    public func startQrVerification( userId: String,  flowId: String ) throws -> QrCode? {
        let _retval = try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_start_qr_verification(self.pointer, userId.lower(), flowId.lower() , $0
    )
}
        return try FfiConverterOptionRecordQrCode.lift(_retval)
    }
    public func scanQrCode( userId: String,  flowId: String,  data: String )  -> ScanResult? {
        let _retval = try!
    rustCall() {
    
    olm_c9b9_OlmMachine_scan_qr_code(self.pointer, userId.lower(), flowId.lower(), data.lower() , $0
    )
}
        return try! FfiConverterOptionRecordScanResult.lift(_retval)
    }
    public func generateQrCode( userId: String,  flowId: String )  -> String? {
        let _retval = try!
    rustCall() {
    
    olm_c9b9_OlmMachine_generate_qr_code(self.pointer, userId.lower(), flowId.lower() , $0
    )
}
        return try! FfiConverterOptionString.lift(_retval)
    }
    public func requestRoomKey( event: String,  roomId: String ) throws -> KeyRequestPair {
        let _retval = try
    rustCallWithError(DecryptionError.self) {
    
    olm_c9b9_OlmMachine_request_room_key(self.pointer, event.lower(), roomId.lower() , $0
    )
}
        return try KeyRequestPair.lift(_retval)
    }
    public func exportKeys( passphrase: String,  rounds: Int32 ) throws -> String {
        let _retval = try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_export_keys(self.pointer, passphrase.lower(), rounds.lower() , $0
    )
}
        return try String.lift(_retval)
    }
    public func importKeys( keys: String,  passphrase: String,  progressListener: ProgressListener ) throws -> KeysImportResult {
        let _retval = try
    rustCallWithError(KeyImportError.self) {
    
    olm_c9b9_OlmMachine_import_keys(self.pointer, keys.lower(), passphrase.lower(), ffiConverterCallbackInterfaceProgressListener.lower(progressListener) , $0
    )
}
        return try KeysImportResult.lift(_retval)
    }
    public func importDecryptedKeys( keys: String,  progressListener: ProgressListener ) throws -> KeysImportResult {
        let _retval = try
    rustCallWithError(KeyImportError.self) {
    
    olm_c9b9_OlmMachine_import_decrypted_keys(self.pointer, keys.lower(), ffiConverterCallbackInterfaceProgressListener.lower(progressListener) , $0
    )
}
        return try KeysImportResult.lift(_retval)
    }
    public func discardRoomKey( roomId: String ) throws {
        try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_discard_room_key(self.pointer, roomId.lower() , $0
    )
}
    }
    public func crossSigningStatus()  -> CrossSigningStatus {
        let _retval = try!
    rustCall() {
    
    olm_c9b9_OlmMachine_cross_signing_status(self.pointer,  $0
    )
}
        return try! CrossSigningStatus.lift(_retval)
    }
    public func bootstrapCrossSigning() throws -> BootstrapCrossSigningResult {
        let _retval = try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_bootstrap_cross_signing(self.pointer,  $0
    )
}
        return try BootstrapCrossSigningResult.lift(_retval)
    }
    public func exportCrossSigningKeys()  -> CrossSigningKeyExport? {
        let _retval = try!
    rustCall() {
    
    olm_c9b9_OlmMachine_export_cross_signing_keys(self.pointer,  $0
    )
}
        return try! FfiConverterOptionRecordCrossSigningKeyExport.lift(_retval)
    }
    public func importCrossSigningKeys( export: CrossSigningKeyExport ) throws {
        try
    rustCallWithError(SecretImportError.self) {
    
    olm_c9b9_OlmMachine_import_cross_signing_keys(self.pointer, export.lower() , $0
    )
}
    }
    public func isIdentityVerified( userId: String ) throws -> Bool {
        let _retval = try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_is_identity_verified(self.pointer, userId.lower() , $0
    )
}
        return try Bool.lift(_retval)
    }
    public func sign( message: String )  -> [String: [String: String]] {
        let _retval = try!
    rustCall() {
    
    olm_c9b9_OlmMachine_sign(self.pointer, message.lower() , $0
    )
}
        return try! FfiConverterDictionaryDictionaryString.lift(_retval)
    }
    public func enableBackupV1( key: MegolmV1BackupKey,  version: String ) throws {
        try
    rustCallWithError(DecodeError.self) {
    
    olm_c9b9_OlmMachine_enable_backup_v1(self.pointer, key.lower(), version.lower() , $0
    )
}
    }
    public func disableBackup() throws {
        try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_disable_backup(self.pointer,  $0
    )
}
    }
    public func backupRoomKeys() throws -> Request? {
        let _retval = try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_backup_room_keys(self.pointer,  $0
    )
}
        return try FfiConverterOptionEnumRequest.lift(_retval)
    }
    public func saveRecoveryKey( key: BackupRecoveryKey?,  version: String? ) throws {
        try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_save_recovery_key(self.pointer, FfiConverterOptionObjectBackupRecoveryKey.lower(key), FfiConverterOptionString.lower(version) , $0
    )
}
    }
    public func roomKeyCounts() throws -> RoomKeyCounts {
        let _retval = try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_room_key_counts(self.pointer,  $0
    )
}
        return try RoomKeyCounts.lift(_retval)
    }
    public func getBackupKeys() throws -> BackupKeys? {
        let _retval = try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_get_backup_keys(self.pointer,  $0
    )
}
        return try FfiConverterOptionObjectBackupKeys.lift(_retval)
    }
    public func backupEnabled()  -> Bool {
        let _retval = try!
    rustCall() {
    
    olm_c9b9_OlmMachine_backup_enabled(self.pointer,  $0
    )
}
        return try! Bool.lift(_retval)
    }
    public func verifyBackup( authData: String ) throws -> Bool {
        let _retval = try
    rustCallWithError(CryptoStoreError.self) {
    
    olm_c9b9_OlmMachine_verify_backup(self.pointer, authData.lower() , $0
    )
}
        return try Bool.lift(_retval)
    }
    
}


fileprivate extension OlmMachine {
    typealias FfiType = UnsafeMutableRawPointer

    static func read(from buf: Reader) throws -> Self {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try self.lift(ptr!)
    }

    func write(into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: self.lower()))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Self {
        return Self(unsafeFromRawPointer: pointer)
    }

    func lower() -> UnsafeMutableRawPointer {
        return self.pointer
    }
}

// Ideally this would be `fileprivate`, but Swift says:
// """
// 'private' modifier cannot be used with extensions that declare protocol conformances
// """
extension OlmMachine : ViaFfi, Serializable {}


public protocol BackupKeysProtocol {
    func recoveryKey()  -> BackupRecoveryKey
    func backupVersion()  -> String
    
}

public class BackupKeys: BackupKeysProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `ViaFfi` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_olm_c9b9_BackupKeys_object_free(pointer, $0) }
    }

    

    
    public func recoveryKey()  -> BackupRecoveryKey {
        let _retval = try!
    rustCall() {
    
    olm_c9b9_BackupKeys_recovery_key(self.pointer,  $0
    )
}
        return try! BackupRecoveryKey.lift(_retval)
    }
    public func backupVersion()  -> String {
        let _retval = try!
    rustCall() {
    
    olm_c9b9_BackupKeys_backup_version(self.pointer,  $0
    )
}
        return try! String.lift(_retval)
    }
    
}


fileprivate extension BackupKeys {
    typealias FfiType = UnsafeMutableRawPointer

    static func read(from buf: Reader) throws -> Self {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try self.lift(ptr!)
    }

    func write(into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: self.lower()))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Self {
        return Self(unsafeFromRawPointer: pointer)
    }

    func lower() -> UnsafeMutableRawPointer {
        return self.pointer
    }
}

// Ideally this would be `fileprivate`, but Swift says:
// """
// 'private' modifier cannot be used with extensions that declare protocol conformances
// """
extension BackupKeys : ViaFfi, Serializable {}


public protocol BackupRecoveryKeyProtocol {
    func toBase58()  -> String
    func toBase64()  -> String
    func megolmV1PublicKey()  -> MegolmV1BackupKey
    func decryptV1( ephemeralKey: String,  mac: String,  ciphertext: String ) throws -> String
    
}

public class BackupRecoveryKey: BackupRecoveryKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `ViaFfi` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try!
    
    
    rustCall() {
    
    olm_c9b9_BackupRecoveryKey_new( $0)
})
    }

    deinit {
        try! rustCall { ffi_olm_c9b9_BackupRecoveryKey_object_free(pointer, $0) }
    }

    
    public static func fromPassphrase( passphrase: String,  salt: String,  rounds: Int32 )  -> BackupRecoveryKey {
        return BackupRecoveryKey(unsafeFromRawPointer: try!
    
    
    rustCall() {
    
    olm_c9b9_BackupRecoveryKey_from_passphrase(passphrase.lower(), salt.lower(), rounds.lower() , $0)
})
    }
    
    public static func newFromPassphrase( passphrase: String )  -> BackupRecoveryKey {
        return BackupRecoveryKey(unsafeFromRawPointer: try!
    
    
    rustCall() {
    
    olm_c9b9_BackupRecoveryKey_new_from_passphrase(passphrase.lower() , $0)
})
    }
    
    public static func fromBase64( key: String ) throws -> BackupRecoveryKey {
        return BackupRecoveryKey(unsafeFromRawPointer: try
    
    
    rustCallWithError(DecodeError.self) {
    
    olm_c9b9_BackupRecoveryKey_from_base64(key.lower() , $0)
})
    }
    
    public static func fromBase58( key: String ) throws -> BackupRecoveryKey {
        return BackupRecoveryKey(unsafeFromRawPointer: try
    
    
    rustCallWithError(DecodeError.self) {
    
    olm_c9b9_BackupRecoveryKey_from_base58(key.lower() , $0)
})
    }
    

    
    public func toBase58()  -> String {
        let _retval = try!
    rustCall() {
    
    olm_c9b9_BackupRecoveryKey_to_base58(self.pointer,  $0
    )
}
        return try! String.lift(_retval)
    }
    public func toBase64()  -> String {
        let _retval = try!
    rustCall() {
    
    olm_c9b9_BackupRecoveryKey_to_base64(self.pointer,  $0
    )
}
        return try! String.lift(_retval)
    }
    public func megolmV1PublicKey()  -> MegolmV1BackupKey {
        let _retval = try!
    rustCall() {
    
    olm_c9b9_BackupRecoveryKey_megolm_v1_public_key(self.pointer,  $0
    )
}
        return try! MegolmV1BackupKey.lift(_retval)
    }
    public func decryptV1( ephemeralKey: String,  mac: String,  ciphertext: String ) throws -> String {
        let _retval = try
    rustCallWithError(PkDecryptionError.self) {
    
    olm_c9b9_BackupRecoveryKey_decrypt_v1(self.pointer, ephemeralKey.lower(), mac.lower(), ciphertext.lower() , $0
    )
}
        return try String.lift(_retval)
    }
    
}


fileprivate extension BackupRecoveryKey {
    typealias FfiType = UnsafeMutableRawPointer

    static func read(from buf: Reader) throws -> Self {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try self.lift(ptr!)
    }

    func write(into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: self.lower()))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Self {
        return Self(unsafeFromRawPointer: pointer)
    }

    func lower() -> UnsafeMutableRawPointer {
        return self.pointer
    }
}

// Ideally this would be `fileprivate`, but Swift says:
// """
// 'private' modifier cannot be used with extensions that declare protocol conformances
// """
extension BackupRecoveryKey : ViaFfi, Serializable {}

public struct DeviceLists {
    public var changed: [String]
    public var left: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(changed: [String], left: [String] ) {
        self.changed = changed
        self.left = left
    }
}


extension DeviceLists: Equatable, Hashable {
    public static func ==(lhs: DeviceLists, rhs: DeviceLists) -> Bool {
        if lhs.changed != rhs.changed {
            return false
        }
        if lhs.left != rhs.left {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(changed)
        hasher.combine(left)
    }
}


fileprivate extension DeviceLists {
    static func read(from buf: Reader) throws -> DeviceLists {
        return try DeviceLists(
            changed: FfiConverterSequenceString.read(from: buf),
            left: FfiConverterSequenceString.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterSequenceString.write(self.changed, into: buf)
        FfiConverterSequenceString.write(self.left, into: buf)
    }
}

extension DeviceLists: ViaFfiUsingByteBuffer, ViaFfi {}

public struct KeysImportResult {
    public var imported: Int64
    public var total: Int64
    public var keys: [String: [String: [String]]]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(imported: Int64, total: Int64, keys: [String: [String: [String]]] ) {
        self.imported = imported
        self.total = total
        self.keys = keys
    }
}


extension KeysImportResult: Equatable, Hashable {
    public static func ==(lhs: KeysImportResult, rhs: KeysImportResult) -> Bool {
        if lhs.imported != rhs.imported {
            return false
        }
        if lhs.total != rhs.total {
            return false
        }
        if lhs.keys != rhs.keys {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(imported)
        hasher.combine(total)
        hasher.combine(keys)
    }
}


fileprivate extension KeysImportResult {
    static func read(from buf: Reader) throws -> KeysImportResult {
        return try KeysImportResult(
            imported: Int64.read(from: buf),
            total: Int64.read(from: buf),
            keys: FfiConverterDictionaryDictionarySequenceString.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        self.imported.write(into: buf)
        self.total.write(into: buf)
        FfiConverterDictionaryDictionarySequenceString.write(self.keys, into: buf)
    }
}

extension KeysImportResult: ViaFfiUsingByteBuffer, ViaFfi {}

public struct DecryptedEvent {
    public var clearEvent: String
    public var senderCurve25519Key: String
    public var claimedEd25519Key: String?
    public var forwardingCurve25519Chain: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(clearEvent: String, senderCurve25519Key: String, claimedEd25519Key: String?, forwardingCurve25519Chain: [String] ) {
        self.clearEvent = clearEvent
        self.senderCurve25519Key = senderCurve25519Key
        self.claimedEd25519Key = claimedEd25519Key
        self.forwardingCurve25519Chain = forwardingCurve25519Chain
    }
}


extension DecryptedEvent: Equatable, Hashable {
    public static func ==(lhs: DecryptedEvent, rhs: DecryptedEvent) -> Bool {
        if lhs.clearEvent != rhs.clearEvent {
            return false
        }
        if lhs.senderCurve25519Key != rhs.senderCurve25519Key {
            return false
        }
        if lhs.claimedEd25519Key != rhs.claimedEd25519Key {
            return false
        }
        if lhs.forwardingCurve25519Chain != rhs.forwardingCurve25519Chain {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(clearEvent)
        hasher.combine(senderCurve25519Key)
        hasher.combine(claimedEd25519Key)
        hasher.combine(forwardingCurve25519Chain)
    }
}


fileprivate extension DecryptedEvent {
    static func read(from buf: Reader) throws -> DecryptedEvent {
        return try DecryptedEvent(
            clearEvent: String.read(from: buf),
            senderCurve25519Key: String.read(from: buf),
            claimedEd25519Key: FfiConverterOptionString.read(from: buf),
            forwardingCurve25519Chain: FfiConverterSequenceString.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        self.clearEvent.write(into: buf)
        self.senderCurve25519Key.write(into: buf)
        FfiConverterOptionString.write(self.claimedEd25519Key, into: buf)
        FfiConverterSequenceString.write(self.forwardingCurve25519Chain, into: buf)
    }
}

extension DecryptedEvent: ViaFfiUsingByteBuffer, ViaFfi {}

public struct Device {
    public var userId: String
    public var deviceId: String
    public var keys: [String: String]
    public var algorithms: [String]
    public var displayName: String?
    public var isBlocked: Bool
    public var locallyTrusted: Bool
    public var crossSigningTrusted: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(userId: String, deviceId: String, keys: [String: String], algorithms: [String], displayName: String?, isBlocked: Bool, locallyTrusted: Bool, crossSigningTrusted: Bool ) {
        self.userId = userId
        self.deviceId = deviceId
        self.keys = keys
        self.algorithms = algorithms
        self.displayName = displayName
        self.isBlocked = isBlocked
        self.locallyTrusted = locallyTrusted
        self.crossSigningTrusted = crossSigningTrusted
    }
}


extension Device: Equatable, Hashable {
    public static func ==(lhs: Device, rhs: Device) -> Bool {
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.deviceId != rhs.deviceId {
            return false
        }
        if lhs.keys != rhs.keys {
            return false
        }
        if lhs.algorithms != rhs.algorithms {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.isBlocked != rhs.isBlocked {
            return false
        }
        if lhs.locallyTrusted != rhs.locallyTrusted {
            return false
        }
        if lhs.crossSigningTrusted != rhs.crossSigningTrusted {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(userId)
        hasher.combine(deviceId)
        hasher.combine(keys)
        hasher.combine(algorithms)
        hasher.combine(displayName)
        hasher.combine(isBlocked)
        hasher.combine(locallyTrusted)
        hasher.combine(crossSigningTrusted)
    }
}


fileprivate extension Device {
    static func read(from buf: Reader) throws -> Device {
        return try Device(
            userId: String.read(from: buf),
            deviceId: String.read(from: buf),
            keys: FfiConverterDictionaryString.read(from: buf),
            algorithms: FfiConverterSequenceString.read(from: buf),
            displayName: FfiConverterOptionString.read(from: buf),
            isBlocked: Bool.read(from: buf),
            locallyTrusted: Bool.read(from: buf),
            crossSigningTrusted: Bool.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        self.userId.write(into: buf)
        self.deviceId.write(into: buf)
        FfiConverterDictionaryString.write(self.keys, into: buf)
        FfiConverterSequenceString.write(self.algorithms, into: buf)
        FfiConverterOptionString.write(self.displayName, into: buf)
        self.isBlocked.write(into: buf)
        self.locallyTrusted.write(into: buf)
        self.crossSigningTrusted.write(into: buf)
    }
}

extension Device: ViaFfiUsingByteBuffer, ViaFfi {}

public struct CrossSigningStatus {
    public var hasMaster: Bool
    public var hasSelfSigning: Bool
    public var hasUserSigning: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(hasMaster: Bool, hasSelfSigning: Bool, hasUserSigning: Bool ) {
        self.hasMaster = hasMaster
        self.hasSelfSigning = hasSelfSigning
        self.hasUserSigning = hasUserSigning
    }
}


extension CrossSigningStatus: Equatable, Hashable {
    public static func ==(lhs: CrossSigningStatus, rhs: CrossSigningStatus) -> Bool {
        if lhs.hasMaster != rhs.hasMaster {
            return false
        }
        if lhs.hasSelfSigning != rhs.hasSelfSigning {
            return false
        }
        if lhs.hasUserSigning != rhs.hasUserSigning {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(hasMaster)
        hasher.combine(hasSelfSigning)
        hasher.combine(hasUserSigning)
    }
}


fileprivate extension CrossSigningStatus {
    static func read(from buf: Reader) throws -> CrossSigningStatus {
        return try CrossSigningStatus(
            hasMaster: Bool.read(from: buf),
            hasSelfSigning: Bool.read(from: buf),
            hasUserSigning: Bool.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        self.hasMaster.write(into: buf)
        self.hasSelfSigning.write(into: buf)
        self.hasUserSigning.write(into: buf)
    }
}

extension CrossSigningStatus: ViaFfiUsingByteBuffer, ViaFfi {}

public struct CrossSigningKeyExport {
    public var masterKey: String?
    public var selfSigningKey: String?
    public var userSigningKey: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(masterKey: String?, selfSigningKey: String?, userSigningKey: String? ) {
        self.masterKey = masterKey
        self.selfSigningKey = selfSigningKey
        self.userSigningKey = userSigningKey
    }
}


extension CrossSigningKeyExport: Equatable, Hashable {
    public static func ==(lhs: CrossSigningKeyExport, rhs: CrossSigningKeyExport) -> Bool {
        if lhs.masterKey != rhs.masterKey {
            return false
        }
        if lhs.selfSigningKey != rhs.selfSigningKey {
            return false
        }
        if lhs.userSigningKey != rhs.userSigningKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(masterKey)
        hasher.combine(selfSigningKey)
        hasher.combine(userSigningKey)
    }
}


fileprivate extension CrossSigningKeyExport {
    static func read(from buf: Reader) throws -> CrossSigningKeyExport {
        return try CrossSigningKeyExport(
            masterKey: FfiConverterOptionString.read(from: buf),
            selfSigningKey: FfiConverterOptionString.read(from: buf),
            userSigningKey: FfiConverterOptionString.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterOptionString.write(self.masterKey, into: buf)
        FfiConverterOptionString.write(self.selfSigningKey, into: buf)
        FfiConverterOptionString.write(self.userSigningKey, into: buf)
    }
}

extension CrossSigningKeyExport: ViaFfiUsingByteBuffer, ViaFfi {}

public struct UploadSigningKeysRequest {
    public var masterKey: String
    public var selfSigningKey: String
    public var userSigningKey: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(masterKey: String, selfSigningKey: String, userSigningKey: String ) {
        self.masterKey = masterKey
        self.selfSigningKey = selfSigningKey
        self.userSigningKey = userSigningKey
    }
}


extension UploadSigningKeysRequest: Equatable, Hashable {
    public static func ==(lhs: UploadSigningKeysRequest, rhs: UploadSigningKeysRequest) -> Bool {
        if lhs.masterKey != rhs.masterKey {
            return false
        }
        if lhs.selfSigningKey != rhs.selfSigningKey {
            return false
        }
        if lhs.userSigningKey != rhs.userSigningKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(masterKey)
        hasher.combine(selfSigningKey)
        hasher.combine(userSigningKey)
    }
}


fileprivate extension UploadSigningKeysRequest {
    static func read(from buf: Reader) throws -> UploadSigningKeysRequest {
        return try UploadSigningKeysRequest(
            masterKey: String.read(from: buf),
            selfSigningKey: String.read(from: buf),
            userSigningKey: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        self.masterKey.write(into: buf)
        self.selfSigningKey.write(into: buf)
        self.userSigningKey.write(into: buf)
    }
}

extension UploadSigningKeysRequest: ViaFfiUsingByteBuffer, ViaFfi {}

public struct BootstrapCrossSigningResult {
    public var uploadSigningKeysRequest: UploadSigningKeysRequest
    public var signatureRequest: SignatureUploadRequest

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(uploadSigningKeysRequest: UploadSigningKeysRequest, signatureRequest: SignatureUploadRequest ) {
        self.uploadSigningKeysRequest = uploadSigningKeysRequest
        self.signatureRequest = signatureRequest
    }
}


extension BootstrapCrossSigningResult: Equatable, Hashable {
    public static func ==(lhs: BootstrapCrossSigningResult, rhs: BootstrapCrossSigningResult) -> Bool {
        if lhs.uploadSigningKeysRequest != rhs.uploadSigningKeysRequest {
            return false
        }
        if lhs.signatureRequest != rhs.signatureRequest {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uploadSigningKeysRequest)
        hasher.combine(signatureRequest)
    }
}


fileprivate extension BootstrapCrossSigningResult {
    static func read(from buf: Reader) throws -> BootstrapCrossSigningResult {
        return try BootstrapCrossSigningResult(
            uploadSigningKeysRequest: UploadSigningKeysRequest.read(from: buf),
            signatureRequest: SignatureUploadRequest.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        self.uploadSigningKeysRequest.write(into: buf)
        self.signatureRequest.write(into: buf)
    }
}

extension BootstrapCrossSigningResult: ViaFfiUsingByteBuffer, ViaFfi {}

public struct CancelInfo {
    public var cancelCode: String
    public var reason: String
    public var cancelledByUs: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(cancelCode: String, reason: String, cancelledByUs: Bool ) {
        self.cancelCode = cancelCode
        self.reason = reason
        self.cancelledByUs = cancelledByUs
    }
}


extension CancelInfo: Equatable, Hashable {
    public static func ==(lhs: CancelInfo, rhs: CancelInfo) -> Bool {
        if lhs.cancelCode != rhs.cancelCode {
            return false
        }
        if lhs.reason != rhs.reason {
            return false
        }
        if lhs.cancelledByUs != rhs.cancelledByUs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(cancelCode)
        hasher.combine(reason)
        hasher.combine(cancelledByUs)
    }
}


fileprivate extension CancelInfo {
    static func read(from buf: Reader) throws -> CancelInfo {
        return try CancelInfo(
            cancelCode: String.read(from: buf),
            reason: String.read(from: buf),
            cancelledByUs: Bool.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        self.cancelCode.write(into: buf)
        self.reason.write(into: buf)
        self.cancelledByUs.write(into: buf)
    }
}

extension CancelInfo: ViaFfiUsingByteBuffer, ViaFfi {}

public struct StartSasResult {
    public var sas: Sas
    public var request: OutgoingVerificationRequest

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(sas: Sas, request: OutgoingVerificationRequest ) {
        self.sas = sas
        self.request = request
    }
}


extension StartSasResult: Equatable, Hashable {
    public static func ==(lhs: StartSasResult, rhs: StartSasResult) -> Bool {
        if lhs.sas != rhs.sas {
            return false
        }
        if lhs.request != rhs.request {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sas)
        hasher.combine(request)
    }
}


fileprivate extension StartSasResult {
    static func read(from buf: Reader) throws -> StartSasResult {
        return try StartSasResult(
            sas: Sas.read(from: buf),
            request: OutgoingVerificationRequest.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        self.sas.write(into: buf)
        self.request.write(into: buf)
    }
}

extension StartSasResult: ViaFfiUsingByteBuffer, ViaFfi {}

public struct Sas {
    public var otherUserId: String
    public var otherDeviceId: String
    public var flowId: String
    public var roomId: String?
    public var weStarted: Bool
    public var hasBeenAccepted: Bool
    public var canBePresented: Bool
    public var supportsEmoji: Bool
    public var haveWeConfirmed: Bool
    public var isDone: Bool
    public var isCancelled: Bool
    public var cancelInfo: CancelInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(otherUserId: String, otherDeviceId: String, flowId: String, roomId: String?, weStarted: Bool, hasBeenAccepted: Bool, canBePresented: Bool, supportsEmoji: Bool, haveWeConfirmed: Bool, isDone: Bool, isCancelled: Bool, cancelInfo: CancelInfo? ) {
        self.otherUserId = otherUserId
        self.otherDeviceId = otherDeviceId
        self.flowId = flowId
        self.roomId = roomId
        self.weStarted = weStarted
        self.hasBeenAccepted = hasBeenAccepted
        self.canBePresented = canBePresented
        self.supportsEmoji = supportsEmoji
        self.haveWeConfirmed = haveWeConfirmed
        self.isDone = isDone
        self.isCancelled = isCancelled
        self.cancelInfo = cancelInfo
    }
}


extension Sas: Equatable, Hashable {
    public static func ==(lhs: Sas, rhs: Sas) -> Bool {
        if lhs.otherUserId != rhs.otherUserId {
            return false
        }
        if lhs.otherDeviceId != rhs.otherDeviceId {
            return false
        }
        if lhs.flowId != rhs.flowId {
            return false
        }
        if lhs.roomId != rhs.roomId {
            return false
        }
        if lhs.weStarted != rhs.weStarted {
            return false
        }
        if lhs.hasBeenAccepted != rhs.hasBeenAccepted {
            return false
        }
        if lhs.canBePresented != rhs.canBePresented {
            return false
        }
        if lhs.supportsEmoji != rhs.supportsEmoji {
            return false
        }
        if lhs.haveWeConfirmed != rhs.haveWeConfirmed {
            return false
        }
        if lhs.isDone != rhs.isDone {
            return false
        }
        if lhs.isCancelled != rhs.isCancelled {
            return false
        }
        if lhs.cancelInfo != rhs.cancelInfo {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(otherUserId)
        hasher.combine(otherDeviceId)
        hasher.combine(flowId)
        hasher.combine(roomId)
        hasher.combine(weStarted)
        hasher.combine(hasBeenAccepted)
        hasher.combine(canBePresented)
        hasher.combine(supportsEmoji)
        hasher.combine(haveWeConfirmed)
        hasher.combine(isDone)
        hasher.combine(isCancelled)
        hasher.combine(cancelInfo)
    }
}


fileprivate extension Sas {
    static func read(from buf: Reader) throws -> Sas {
        return try Sas(
            otherUserId: String.read(from: buf),
            otherDeviceId: String.read(from: buf),
            flowId: String.read(from: buf),
            roomId: FfiConverterOptionString.read(from: buf),
            weStarted: Bool.read(from: buf),
            hasBeenAccepted: Bool.read(from: buf),
            canBePresented: Bool.read(from: buf),
            supportsEmoji: Bool.read(from: buf),
            haveWeConfirmed: Bool.read(from: buf),
            isDone: Bool.read(from: buf),
            isCancelled: Bool.read(from: buf),
            cancelInfo: FfiConverterOptionRecordCancelInfo.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        self.otherUserId.write(into: buf)
        self.otherDeviceId.write(into: buf)
        self.flowId.write(into: buf)
        FfiConverterOptionString.write(self.roomId, into: buf)
        self.weStarted.write(into: buf)
        self.hasBeenAccepted.write(into: buf)
        self.canBePresented.write(into: buf)
        self.supportsEmoji.write(into: buf)
        self.haveWeConfirmed.write(into: buf)
        self.isDone.write(into: buf)
        self.isCancelled.write(into: buf)
        FfiConverterOptionRecordCancelInfo.write(self.cancelInfo, into: buf)
    }
}

extension Sas: ViaFfiUsingByteBuffer, ViaFfi {}

public struct ScanResult {
    public var qr: QrCode
    public var request: OutgoingVerificationRequest

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(qr: QrCode, request: OutgoingVerificationRequest ) {
        self.qr = qr
        self.request = request
    }
}


extension ScanResult: Equatable, Hashable {
    public static func ==(lhs: ScanResult, rhs: ScanResult) -> Bool {
        if lhs.qr != rhs.qr {
            return false
        }
        if lhs.request != rhs.request {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(qr)
        hasher.combine(request)
    }
}


fileprivate extension ScanResult {
    static func read(from buf: Reader) throws -> ScanResult {
        return try ScanResult(
            qr: QrCode.read(from: buf),
            request: OutgoingVerificationRequest.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        self.qr.write(into: buf)
        self.request.write(into: buf)
    }
}

extension ScanResult: ViaFfiUsingByteBuffer, ViaFfi {}

public struct QrCode {
    public var otherUserId: String
    public var otherDeviceId: String
    public var flowId: String
    public var roomId: String?
    public var weStarted: Bool
    public var otherSideScanned: Bool
    public var hasBeenConfirmed: Bool
    public var reciprocated: Bool
    public var isDone: Bool
    public var isCancelled: Bool
    public var cancelInfo: CancelInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(otherUserId: String, otherDeviceId: String, flowId: String, roomId: String?, weStarted: Bool, otherSideScanned: Bool, hasBeenConfirmed: Bool, reciprocated: Bool, isDone: Bool, isCancelled: Bool, cancelInfo: CancelInfo? ) {
        self.otherUserId = otherUserId
        self.otherDeviceId = otherDeviceId
        self.flowId = flowId
        self.roomId = roomId
        self.weStarted = weStarted
        self.otherSideScanned = otherSideScanned
        self.hasBeenConfirmed = hasBeenConfirmed
        self.reciprocated = reciprocated
        self.isDone = isDone
        self.isCancelled = isCancelled
        self.cancelInfo = cancelInfo
    }
}


extension QrCode: Equatable, Hashable {
    public static func ==(lhs: QrCode, rhs: QrCode) -> Bool {
        if lhs.otherUserId != rhs.otherUserId {
            return false
        }
        if lhs.otherDeviceId != rhs.otherDeviceId {
            return false
        }
        if lhs.flowId != rhs.flowId {
            return false
        }
        if lhs.roomId != rhs.roomId {
            return false
        }
        if lhs.weStarted != rhs.weStarted {
            return false
        }
        if lhs.otherSideScanned != rhs.otherSideScanned {
            return false
        }
        if lhs.hasBeenConfirmed != rhs.hasBeenConfirmed {
            return false
        }
        if lhs.reciprocated != rhs.reciprocated {
            return false
        }
        if lhs.isDone != rhs.isDone {
            return false
        }
        if lhs.isCancelled != rhs.isCancelled {
            return false
        }
        if lhs.cancelInfo != rhs.cancelInfo {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(otherUserId)
        hasher.combine(otherDeviceId)
        hasher.combine(flowId)
        hasher.combine(roomId)
        hasher.combine(weStarted)
        hasher.combine(otherSideScanned)
        hasher.combine(hasBeenConfirmed)
        hasher.combine(reciprocated)
        hasher.combine(isDone)
        hasher.combine(isCancelled)
        hasher.combine(cancelInfo)
    }
}


fileprivate extension QrCode {
    static func read(from buf: Reader) throws -> QrCode {
        return try QrCode(
            otherUserId: String.read(from: buf),
            otherDeviceId: String.read(from: buf),
            flowId: String.read(from: buf),
            roomId: FfiConverterOptionString.read(from: buf),
            weStarted: Bool.read(from: buf),
            otherSideScanned: Bool.read(from: buf),
            hasBeenConfirmed: Bool.read(from: buf),
            reciprocated: Bool.read(from: buf),
            isDone: Bool.read(from: buf),
            isCancelled: Bool.read(from: buf),
            cancelInfo: FfiConverterOptionRecordCancelInfo.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        self.otherUserId.write(into: buf)
        self.otherDeviceId.write(into: buf)
        self.flowId.write(into: buf)
        FfiConverterOptionString.write(self.roomId, into: buf)
        self.weStarted.write(into: buf)
        self.otherSideScanned.write(into: buf)
        self.hasBeenConfirmed.write(into: buf)
        self.reciprocated.write(into: buf)
        self.isDone.write(into: buf)
        self.isCancelled.write(into: buf)
        FfiConverterOptionRecordCancelInfo.write(self.cancelInfo, into: buf)
    }
}

extension QrCode: ViaFfiUsingByteBuffer, ViaFfi {}

public struct VerificationRequest {
    public var otherUserId: String
    public var otherDeviceId: String?
    public var flowId: String
    public var roomId: String?
    public var weStarted: Bool
    public var isReady: Bool
    public var isPassive: Bool
    public var isDone: Bool
    public var isCancelled: Bool
    public var cancelInfo: CancelInfo?
    public var theirMethods: [String]?
    public var ourMethods: [String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(otherUserId: String, otherDeviceId: String?, flowId: String, roomId: String?, weStarted: Bool, isReady: Bool, isPassive: Bool, isDone: Bool, isCancelled: Bool, cancelInfo: CancelInfo?, theirMethods: [String]?, ourMethods: [String]? ) {
        self.otherUserId = otherUserId
        self.otherDeviceId = otherDeviceId
        self.flowId = flowId
        self.roomId = roomId
        self.weStarted = weStarted
        self.isReady = isReady
        self.isPassive = isPassive
        self.isDone = isDone
        self.isCancelled = isCancelled
        self.cancelInfo = cancelInfo
        self.theirMethods = theirMethods
        self.ourMethods = ourMethods
    }
}


extension VerificationRequest: Equatable, Hashable {
    public static func ==(lhs: VerificationRequest, rhs: VerificationRequest) -> Bool {
        if lhs.otherUserId != rhs.otherUserId {
            return false
        }
        if lhs.otherDeviceId != rhs.otherDeviceId {
            return false
        }
        if lhs.flowId != rhs.flowId {
            return false
        }
        if lhs.roomId != rhs.roomId {
            return false
        }
        if lhs.weStarted != rhs.weStarted {
            return false
        }
        if lhs.isReady != rhs.isReady {
            return false
        }
        if lhs.isPassive != rhs.isPassive {
            return false
        }
        if lhs.isDone != rhs.isDone {
            return false
        }
        if lhs.isCancelled != rhs.isCancelled {
            return false
        }
        if lhs.cancelInfo != rhs.cancelInfo {
            return false
        }
        if lhs.theirMethods != rhs.theirMethods {
            return false
        }
        if lhs.ourMethods != rhs.ourMethods {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(otherUserId)
        hasher.combine(otherDeviceId)
        hasher.combine(flowId)
        hasher.combine(roomId)
        hasher.combine(weStarted)
        hasher.combine(isReady)
        hasher.combine(isPassive)
        hasher.combine(isDone)
        hasher.combine(isCancelled)
        hasher.combine(cancelInfo)
        hasher.combine(theirMethods)
        hasher.combine(ourMethods)
    }
}


fileprivate extension VerificationRequest {
    static func read(from buf: Reader) throws -> VerificationRequest {
        return try VerificationRequest(
            otherUserId: String.read(from: buf),
            otherDeviceId: FfiConverterOptionString.read(from: buf),
            flowId: String.read(from: buf),
            roomId: FfiConverterOptionString.read(from: buf),
            weStarted: Bool.read(from: buf),
            isReady: Bool.read(from: buf),
            isPassive: Bool.read(from: buf),
            isDone: Bool.read(from: buf),
            isCancelled: Bool.read(from: buf),
            cancelInfo: FfiConverterOptionRecordCancelInfo.read(from: buf),
            theirMethods: FfiConverterOptionSequenceString.read(from: buf),
            ourMethods: FfiConverterOptionSequenceString.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        self.otherUserId.write(into: buf)
        FfiConverterOptionString.write(self.otherDeviceId, into: buf)
        self.flowId.write(into: buf)
        FfiConverterOptionString.write(self.roomId, into: buf)
        self.weStarted.write(into: buf)
        self.isReady.write(into: buf)
        self.isPassive.write(into: buf)
        self.isDone.write(into: buf)
        self.isCancelled.write(into: buf)
        FfiConverterOptionRecordCancelInfo.write(self.cancelInfo, into: buf)
        FfiConverterOptionSequenceString.write(self.theirMethods, into: buf)
        FfiConverterOptionSequenceString.write(self.ourMethods, into: buf)
    }
}

extension VerificationRequest: ViaFfiUsingByteBuffer, ViaFfi {}

public struct RequestVerificationResult {
    public var verification: VerificationRequest
    public var request: OutgoingVerificationRequest

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(verification: VerificationRequest, request: OutgoingVerificationRequest ) {
        self.verification = verification
        self.request = request
    }
}


extension RequestVerificationResult: Equatable, Hashable {
    public static func ==(lhs: RequestVerificationResult, rhs: RequestVerificationResult) -> Bool {
        if lhs.verification != rhs.verification {
            return false
        }
        if lhs.request != rhs.request {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(verification)
        hasher.combine(request)
    }
}


fileprivate extension RequestVerificationResult {
    static func read(from buf: Reader) throws -> RequestVerificationResult {
        return try RequestVerificationResult(
            verification: VerificationRequest.read(from: buf),
            request: OutgoingVerificationRequest.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        self.verification.write(into: buf)
        self.request.write(into: buf)
    }
}

extension RequestVerificationResult: ViaFfiUsingByteBuffer, ViaFfi {}

public struct ConfirmVerificationResult {
    public var requests: [OutgoingVerificationRequest]
    public var signatureRequest: SignatureUploadRequest?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(requests: [OutgoingVerificationRequest], signatureRequest: SignatureUploadRequest? ) {
        self.requests = requests
        self.signatureRequest = signatureRequest
    }
}


extension ConfirmVerificationResult: Equatable, Hashable {
    public static func ==(lhs: ConfirmVerificationResult, rhs: ConfirmVerificationResult) -> Bool {
        if lhs.requests != rhs.requests {
            return false
        }
        if lhs.signatureRequest != rhs.signatureRequest {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(requests)
        hasher.combine(signatureRequest)
    }
}


fileprivate extension ConfirmVerificationResult {
    static func read(from buf: Reader) throws -> ConfirmVerificationResult {
        return try ConfirmVerificationResult(
            requests: FfiConverterSequenceEnumOutgoingVerificationRequest.read(from: buf),
            signatureRequest: FfiConverterOptionRecordSignatureUploadRequest.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterSequenceEnumOutgoingVerificationRequest.write(self.requests, into: buf)
        FfiConverterOptionRecordSignatureUploadRequest.write(self.signatureRequest, into: buf)
    }
}

extension ConfirmVerificationResult: ViaFfiUsingByteBuffer, ViaFfi {}

public struct KeyRequestPair {
    public var cancellation: Request?
    public var keyRequest: Request

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(cancellation: Request?, keyRequest: Request ) {
        self.cancellation = cancellation
        self.keyRequest = keyRequest
    }
}


extension KeyRequestPair: Equatable, Hashable {
    public static func ==(lhs: KeyRequestPair, rhs: KeyRequestPair) -> Bool {
        if lhs.cancellation != rhs.cancellation {
            return false
        }
        if lhs.keyRequest != rhs.keyRequest {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(cancellation)
        hasher.combine(keyRequest)
    }
}


fileprivate extension KeyRequestPair {
    static func read(from buf: Reader) throws -> KeyRequestPair {
        return try KeyRequestPair(
            cancellation: FfiConverterOptionEnumRequest.read(from: buf),
            keyRequest: Request.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterOptionEnumRequest.write(self.cancellation, into: buf)
        self.keyRequest.write(into: buf)
    }
}

extension KeyRequestPair: ViaFfiUsingByteBuffer, ViaFfi {}

public struct SignatureUploadRequest {
    public var body: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(body: String ) {
        self.body = body
    }
}


extension SignatureUploadRequest: Equatable, Hashable {
    public static func ==(lhs: SignatureUploadRequest, rhs: SignatureUploadRequest) -> Bool {
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(body)
    }
}


fileprivate extension SignatureUploadRequest {
    static func read(from buf: Reader) throws -> SignatureUploadRequest {
        return try SignatureUploadRequest(
            body: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        self.body.write(into: buf)
    }
}

extension SignatureUploadRequest: ViaFfiUsingByteBuffer, ViaFfi {}

public struct PassphraseInfo {
    public var privateKeySalt: String
    public var privateKeyIterations: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(privateKeySalt: String, privateKeyIterations: Int32 ) {
        self.privateKeySalt = privateKeySalt
        self.privateKeyIterations = privateKeyIterations
    }
}


extension PassphraseInfo: Equatable, Hashable {
    public static func ==(lhs: PassphraseInfo, rhs: PassphraseInfo) -> Bool {
        if lhs.privateKeySalt != rhs.privateKeySalt {
            return false
        }
        if lhs.privateKeyIterations != rhs.privateKeyIterations {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(privateKeySalt)
        hasher.combine(privateKeyIterations)
    }
}


fileprivate extension PassphraseInfo {
    static func read(from buf: Reader) throws -> PassphraseInfo {
        return try PassphraseInfo(
            privateKeySalt: String.read(from: buf),
            privateKeyIterations: Int32.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        self.privateKeySalt.write(into: buf)
        self.privateKeyIterations.write(into: buf)
    }
}

extension PassphraseInfo: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MegolmV1BackupKey {
    public var publicKey: String
    public var signatures: [String: [String: String]]
    public var passphraseInfo: PassphraseInfo?
    public var backupAlgorithm: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publicKey: String, signatures: [String: [String: String]], passphraseInfo: PassphraseInfo?, backupAlgorithm: String ) {
        self.publicKey = publicKey
        self.signatures = signatures
        self.passphraseInfo = passphraseInfo
        self.backupAlgorithm = backupAlgorithm
    }
}


extension MegolmV1BackupKey: Equatable, Hashable {
    public static func ==(lhs: MegolmV1BackupKey, rhs: MegolmV1BackupKey) -> Bool {
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.signatures != rhs.signatures {
            return false
        }
        if lhs.passphraseInfo != rhs.passphraseInfo {
            return false
        }
        if lhs.backupAlgorithm != rhs.backupAlgorithm {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publicKey)
        hasher.combine(signatures)
        hasher.combine(passphraseInfo)
        hasher.combine(backupAlgorithm)
    }
}


fileprivate extension MegolmV1BackupKey {
    static func read(from buf: Reader) throws -> MegolmV1BackupKey {
        return try MegolmV1BackupKey(
            publicKey: String.read(from: buf),
            signatures: FfiConverterDictionaryDictionaryString.read(from: buf),
            passphraseInfo: FfiConverterOptionRecordPassphraseInfo.read(from: buf),
            backupAlgorithm: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        self.publicKey.write(into: buf)
        FfiConverterDictionaryDictionaryString.write(self.signatures, into: buf)
        FfiConverterOptionRecordPassphraseInfo.write(self.passphraseInfo, into: buf)
        self.backupAlgorithm.write(into: buf)
    }
}

extension MegolmV1BackupKey: ViaFfiUsingByteBuffer, ViaFfi {}

public struct RoomKeyCounts {
    public var total: Int64
    public var backedUp: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(total: Int64, backedUp: Int64 ) {
        self.total = total
        self.backedUp = backedUp
    }
}


extension RoomKeyCounts: Equatable, Hashable {
    public static func ==(lhs: RoomKeyCounts, rhs: RoomKeyCounts) -> Bool {
        if lhs.total != rhs.total {
            return false
        }
        if lhs.backedUp != rhs.backedUp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(total)
        hasher.combine(backedUp)
    }
}


fileprivate extension RoomKeyCounts {
    static func read(from buf: Reader) throws -> RoomKeyCounts {
        return try RoomKeyCounts(
            total: Int64.read(from: buf),
            backedUp: Int64.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        self.total.write(into: buf)
        self.backedUp.write(into: buf)
    }
}

extension RoomKeyCounts: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MigrationData {
    public var account: PickledAccount
    public var sessions: [PickledSession]
    public var inboundGroupSessions: [PickledInboundGroupSession]
    public var backupVersion: String?
    public var backupRecoveryKey: String?
    public var pickleKey: [UInt8]
    public var crossSigning: CrossSigningKeyExport
    public var trackedUsers: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(account: PickledAccount, sessions: [PickledSession], inboundGroupSessions: [PickledInboundGroupSession], backupVersion: String?, backupRecoveryKey: String?, pickleKey: [UInt8], crossSigning: CrossSigningKeyExport, trackedUsers: [String] ) {
        self.account = account
        self.sessions = sessions
        self.inboundGroupSessions = inboundGroupSessions
        self.backupVersion = backupVersion
        self.backupRecoveryKey = backupRecoveryKey
        self.pickleKey = pickleKey
        self.crossSigning = crossSigning
        self.trackedUsers = trackedUsers
    }
}


extension MigrationData: Equatable, Hashable {
    public static func ==(lhs: MigrationData, rhs: MigrationData) -> Bool {
        if lhs.account != rhs.account {
            return false
        }
        if lhs.sessions != rhs.sessions {
            return false
        }
        if lhs.inboundGroupSessions != rhs.inboundGroupSessions {
            return false
        }
        if lhs.backupVersion != rhs.backupVersion {
            return false
        }
        if lhs.backupRecoveryKey != rhs.backupRecoveryKey {
            return false
        }
        if lhs.pickleKey != rhs.pickleKey {
            return false
        }
        if lhs.crossSigning != rhs.crossSigning {
            return false
        }
        if lhs.trackedUsers != rhs.trackedUsers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(account)
        hasher.combine(sessions)
        hasher.combine(inboundGroupSessions)
        hasher.combine(backupVersion)
        hasher.combine(backupRecoveryKey)
        hasher.combine(pickleKey)
        hasher.combine(crossSigning)
        hasher.combine(trackedUsers)
    }
}


fileprivate extension MigrationData {
    static func read(from buf: Reader) throws -> MigrationData {
        return try MigrationData(
            account: PickledAccount.read(from: buf),
            sessions: FfiConverterSequenceRecordPickledSession.read(from: buf),
            inboundGroupSessions: FfiConverterSequenceRecordPickledInboundGroupSession.read(from: buf),
            backupVersion: FfiConverterOptionString.read(from: buf),
            backupRecoveryKey: FfiConverterOptionString.read(from: buf),
            pickleKey: FfiConverterSequenceUInt8.read(from: buf),
            crossSigning: CrossSigningKeyExport.read(from: buf),
            trackedUsers: FfiConverterSequenceString.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        self.account.write(into: buf)
        FfiConverterSequenceRecordPickledSession.write(self.sessions, into: buf)
        FfiConverterSequenceRecordPickledInboundGroupSession.write(self.inboundGroupSessions, into: buf)
        FfiConverterOptionString.write(self.backupVersion, into: buf)
        FfiConverterOptionString.write(self.backupRecoveryKey, into: buf)
        FfiConverterSequenceUInt8.write(self.pickleKey, into: buf)
        self.crossSigning.write(into: buf)
        FfiConverterSequenceString.write(self.trackedUsers, into: buf)
    }
}

extension MigrationData: ViaFfiUsingByteBuffer, ViaFfi {}

public struct PickledAccount {
    public var userId: String
    public var deviceId: String
    public var pickle: String
    public var shared: Bool
    public var uploadedSignedKeyCount: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(userId: String, deviceId: String, pickle: String, shared: Bool, uploadedSignedKeyCount: Int64 ) {
        self.userId = userId
        self.deviceId = deviceId
        self.pickle = pickle
        self.shared = shared
        self.uploadedSignedKeyCount = uploadedSignedKeyCount
    }
}


extension PickledAccount: Equatable, Hashable {
    public static func ==(lhs: PickledAccount, rhs: PickledAccount) -> Bool {
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.deviceId != rhs.deviceId {
            return false
        }
        if lhs.pickle != rhs.pickle {
            return false
        }
        if lhs.shared != rhs.shared {
            return false
        }
        if lhs.uploadedSignedKeyCount != rhs.uploadedSignedKeyCount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(userId)
        hasher.combine(deviceId)
        hasher.combine(pickle)
        hasher.combine(shared)
        hasher.combine(uploadedSignedKeyCount)
    }
}


fileprivate extension PickledAccount {
    static func read(from buf: Reader) throws -> PickledAccount {
        return try PickledAccount(
            userId: String.read(from: buf),
            deviceId: String.read(from: buf),
            pickle: String.read(from: buf),
            shared: Bool.read(from: buf),
            uploadedSignedKeyCount: Int64.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        self.userId.write(into: buf)
        self.deviceId.write(into: buf)
        self.pickle.write(into: buf)
        self.shared.write(into: buf)
        self.uploadedSignedKeyCount.write(into: buf)
    }
}

extension PickledAccount: ViaFfiUsingByteBuffer, ViaFfi {}

public struct PickledSession {
    public var pickle: String
    public var senderKey: String
    public var createdUsingFallbackKey: Bool
    public var creationTime: String
    public var lastUseTime: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(pickle: String, senderKey: String, createdUsingFallbackKey: Bool, creationTime: String, lastUseTime: String ) {
        self.pickle = pickle
        self.senderKey = senderKey
        self.createdUsingFallbackKey = createdUsingFallbackKey
        self.creationTime = creationTime
        self.lastUseTime = lastUseTime
    }
}


extension PickledSession: Equatable, Hashable {
    public static func ==(lhs: PickledSession, rhs: PickledSession) -> Bool {
        if lhs.pickle != rhs.pickle {
            return false
        }
        if lhs.senderKey != rhs.senderKey {
            return false
        }
        if lhs.createdUsingFallbackKey != rhs.createdUsingFallbackKey {
            return false
        }
        if lhs.creationTime != rhs.creationTime {
            return false
        }
        if lhs.lastUseTime != rhs.lastUseTime {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pickle)
        hasher.combine(senderKey)
        hasher.combine(createdUsingFallbackKey)
        hasher.combine(creationTime)
        hasher.combine(lastUseTime)
    }
}


fileprivate extension PickledSession {
    static func read(from buf: Reader) throws -> PickledSession {
        return try PickledSession(
            pickle: String.read(from: buf),
            senderKey: String.read(from: buf),
            createdUsingFallbackKey: Bool.read(from: buf),
            creationTime: String.read(from: buf),
            lastUseTime: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        self.pickle.write(into: buf)
        self.senderKey.write(into: buf)
        self.createdUsingFallbackKey.write(into: buf)
        self.creationTime.write(into: buf)
        self.lastUseTime.write(into: buf)
    }
}

extension PickledSession: ViaFfiUsingByteBuffer, ViaFfi {}

public struct PickledInboundGroupSession {
    public var pickle: String
    public var senderKey: String
    public var signingKey: [String: String]
    public var roomId: String
    public var forwardingChains: [String]
    public var imported: Bool
    public var backedUp: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(pickle: String, senderKey: String, signingKey: [String: String], roomId: String, forwardingChains: [String], imported: Bool, backedUp: Bool ) {
        self.pickle = pickle
        self.senderKey = senderKey
        self.signingKey = signingKey
        self.roomId = roomId
        self.forwardingChains = forwardingChains
        self.imported = imported
        self.backedUp = backedUp
    }
}


extension PickledInboundGroupSession: Equatable, Hashable {
    public static func ==(lhs: PickledInboundGroupSession, rhs: PickledInboundGroupSession) -> Bool {
        if lhs.pickle != rhs.pickle {
            return false
        }
        if lhs.senderKey != rhs.senderKey {
            return false
        }
        if lhs.signingKey != rhs.signingKey {
            return false
        }
        if lhs.roomId != rhs.roomId {
            return false
        }
        if lhs.forwardingChains != rhs.forwardingChains {
            return false
        }
        if lhs.imported != rhs.imported {
            return false
        }
        if lhs.backedUp != rhs.backedUp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pickle)
        hasher.combine(senderKey)
        hasher.combine(signingKey)
        hasher.combine(roomId)
        hasher.combine(forwardingChains)
        hasher.combine(imported)
        hasher.combine(backedUp)
    }
}


fileprivate extension PickledInboundGroupSession {
    static func read(from buf: Reader) throws -> PickledInboundGroupSession {
        return try PickledInboundGroupSession(
            pickle: String.read(from: buf),
            senderKey: String.read(from: buf),
            signingKey: FfiConverterDictionaryString.read(from: buf),
            roomId: String.read(from: buf),
            forwardingChains: FfiConverterSequenceString.read(from: buf),
            imported: Bool.read(from: buf),
            backedUp: Bool.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        self.pickle.write(into: buf)
        self.senderKey.write(into: buf)
        FfiConverterDictionaryString.write(self.signingKey, into: buf)
        self.roomId.write(into: buf)
        FfiConverterSequenceString.write(self.forwardingChains, into: buf)
        self.imported.write(into: buf)
        self.backedUp.write(into: buf)
    }
}

extension PickledInboundGroupSession: ViaFfiUsingByteBuffer, ViaFfi {}

public enum MigrationError {

    
    
    case Generic(errorMessage: String )
}

extension MigrationError: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> MigrationError {
        let variant: Int32 = try buf.readInt()
        switch variant {

        

       

        
        case 1: return .Generic(
            errorMessage: try String.read(from: buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {

        

        

        
        
        case let .Generic(errorMessage):
            buf.writeInt(Int32(1))
            errorMessage.write(into: buf)
            
        
        }
    }
}


extension MigrationError: Equatable, Hashable {}

extension MigrationError: Error { }

public enum PkDecryptionError {

    
    
    // Simple error enums only carry a message
    case Olm(message: String)
    
}

extension PkDecryptionError: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> PkDecryptionError {
        let variant: Int32 = try buf.readInt()
        switch variant {

        

        
        case 1: return .Olm(
            message: try String.read(from: buf)
        )
        

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {

        

        
        case let .Olm(message):
            buf.writeInt(Int32(1))
            message.write(into: buf)
        }
    }
}


extension PkDecryptionError: Equatable, Hashable {}

extension PkDecryptionError: Error { }

public enum KeyImportError {

    
    
    // Simple error enums only carry a message
    case Export(message: String)
    
    // Simple error enums only carry a message
    case CryptoStore(message: String)
    
    // Simple error enums only carry a message
    case Json(message: String)
    
}

extension KeyImportError: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> KeyImportError {
        let variant: Int32 = try buf.readInt()
        switch variant {

        

        
        case 1: return .Export(
            message: try String.read(from: buf)
        )
        
        case 2: return .CryptoStore(
            message: try String.read(from: buf)
        )
        
        case 3: return .Json(
            message: try String.read(from: buf)
        )
        

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {

        

        
        case let .Export(message):
            buf.writeInt(Int32(1))
            message.write(into: buf)
        case let .CryptoStore(message):
            buf.writeInt(Int32(2))
            message.write(into: buf)
        case let .Json(message):
            buf.writeInt(Int32(3))
            message.write(into: buf)
        }
    }
}


extension KeyImportError: Equatable, Hashable {}

extension KeyImportError: Error { }

public enum SignatureError {

    
    
    // Simple error enums only carry a message
    case Signature(message: String)
    
    // Simple error enums only carry a message
    case Identifier(message: String)
    
    // Simple error enums only carry a message
    case CryptoStore(message: String)
    
    // Simple error enums only carry a message
    case UnknownDevice(message: String)
    
    // Simple error enums only carry a message
    case UnknownUserIdentity(message: String)
    
}

extension SignatureError: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> SignatureError {
        let variant: Int32 = try buf.readInt()
        switch variant {

        

        
        case 1: return .Signature(
            message: try String.read(from: buf)
        )
        
        case 2: return .Identifier(
            message: try String.read(from: buf)
        )
        
        case 3: return .CryptoStore(
            message: try String.read(from: buf)
        )
        
        case 4: return .UnknownDevice(
            message: try String.read(from: buf)
        )
        
        case 5: return .UnknownUserIdentity(
            message: try String.read(from: buf)
        )
        

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {

        

        
        case let .Signature(message):
            buf.writeInt(Int32(1))
            message.write(into: buf)
        case let .Identifier(message):
            buf.writeInt(Int32(2))
            message.write(into: buf)
        case let .CryptoStore(message):
            buf.writeInt(Int32(3))
            message.write(into: buf)
        case let .UnknownDevice(message):
            buf.writeInt(Int32(4))
            message.write(into: buf)
        case let .UnknownUserIdentity(message):
            buf.writeInt(Int32(5))
            message.write(into: buf)
        }
    }
}


extension SignatureError: Equatable, Hashable {}

extension SignatureError: Error { }

public enum SecretImportError {

    
    
    // Simple error enums only carry a message
    case Import(message: String)
    
    // Simple error enums only carry a message
    case CryptoStore(message: String)
    
}

extension SecretImportError: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> SecretImportError {
        let variant: Int32 = try buf.readInt()
        switch variant {

        

        
        case 1: return .Import(
            message: try String.read(from: buf)
        )
        
        case 2: return .CryptoStore(
            message: try String.read(from: buf)
        )
        

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {

        

        
        case let .Import(message):
            buf.writeInt(Int32(1))
            message.write(into: buf)
        case let .CryptoStore(message):
            buf.writeInt(Int32(2))
            message.write(into: buf)
        }
    }
}


extension SecretImportError: Equatable, Hashable {}

extension SecretImportError: Error { }

public enum CryptoStoreError {

    
    
    // Simple error enums only carry a message
    case CryptoStore(message: String)
    
    // Simple error enums only carry a message
    case OlmError(message: String)
    
    // Simple error enums only carry a message
    case Serialization(message: String)
    
    // Simple error enums only carry a message
    case Identifier(message: String)
    
    // Simple error enums only carry a message
    case InvalidUserId(message: String)
    
}

extension CryptoStoreError: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> CryptoStoreError {
        let variant: Int32 = try buf.readInt()
        switch variant {

        

        
        case 1: return .CryptoStore(
            message: try String.read(from: buf)
        )
        
        case 2: return .OlmError(
            message: try String.read(from: buf)
        )
        
        case 3: return .Serialization(
            message: try String.read(from: buf)
        )
        
        case 4: return .Identifier(
            message: try String.read(from: buf)
        )
        
        case 5: return .InvalidUserId(
            message: try String.read(from: buf)
        )
        

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {

        

        
        case let .CryptoStore(message):
            buf.writeInt(Int32(1))
            message.write(into: buf)
        case let .OlmError(message):
            buf.writeInt(Int32(2))
            message.write(into: buf)
        case let .Serialization(message):
            buf.writeInt(Int32(3))
            message.write(into: buf)
        case let .Identifier(message):
            buf.writeInt(Int32(4))
            message.write(into: buf)
        case let .InvalidUserId(message):
            buf.writeInt(Int32(5))
            message.write(into: buf)
        }
    }
}


extension CryptoStoreError: Equatable, Hashable {}

extension CryptoStoreError: Error { }

public enum DecryptionError {

    
    
    // Simple error enums only carry a message
    case Identifier(message: String)
    
    // Simple error enums only carry a message
    case Serialization(message: String)
    
    // Simple error enums only carry a message
    case Megolm(message: String)
    
}

extension DecryptionError: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> DecryptionError {
        let variant: Int32 = try buf.readInt()
        switch variant {

        

        
        case 1: return .Identifier(
            message: try String.read(from: buf)
        )
        
        case 2: return .Serialization(
            message: try String.read(from: buf)
        )
        
        case 3: return .Megolm(
            message: try String.read(from: buf)
        )
        

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {

        

        
        case let .Identifier(message):
            buf.writeInt(Int32(1))
            message.write(into: buf)
        case let .Serialization(message):
            buf.writeInt(Int32(2))
            message.write(into: buf)
        case let .Megolm(message):
            buf.writeInt(Int32(3))
            message.write(into: buf)
        }
    }
}


extension DecryptionError: Equatable, Hashable {}

extension DecryptionError: Error { }

public enum DecodeError {

    
    
    // Simple error enums only carry a message
    case Decode(message: String)
    
    // Simple error enums only carry a message
    case CryptoStore(message: String)
    
}

extension DecodeError: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> DecodeError {
        let variant: Int32 = try buf.readInt()
        switch variant {

        

        
        case 1: return .Decode(
            message: try String.read(from: buf)
        )
        
        case 2: return .CryptoStore(
            message: try String.read(from: buf)
        )
        

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {

        

        
        case let .Decode(message):
            buf.writeInt(Int32(1))
            message.write(into: buf)
        case let .CryptoStore(message):
            buf.writeInt(Int32(2))
            message.write(into: buf)
        }
    }
}


extension DecodeError: Equatable, Hashable {}

extension DecodeError: Error { }


// Declaration and FfiConverters for Logger Callback Interface

public protocol Logger : AnyObject {
    func log( logLine: String ) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceLogger : ForeignCallback =
    { (handle: Handle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func invokeLog(_ swiftCallbackInterface: Logger, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }

            let reader = Reader(data: Data(rustBuffer: args))
              swiftCallbackInterface.log(
                    logLine: try String.read(from: reader) 
                    )
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

    }
    

        let cb = try! ffiConverterCallbackInterfaceLogger.lift(handle)
        switch method {
            case IDX_CALLBACK_FREE:
                ffiConverterCallbackInterfaceLogger.drop(handle: handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 0
            case 1:
                let buffer = try! invokeLog(cb, args)
                out_buf.pointee = buffer
                // Value written to out buffer.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 1
            
            // This should never happen, because an out of bounds method index won't
            // ever be used. Once we can catch errors, we should return an InternalError.
            // https://github.com/mozilla/uniffi-rs/issues/351
            default:
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return -1
        }
    }

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
private let ffiConverterCallbackInterfaceLogger: FfiConverterCallbackInterface<Logger> = {
    try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            ffi_olm_c9b9_Logger_init_callback(foreignCallbackCallbackInterfaceLogger, err)
    }
    return FfiConverterCallbackInterface<Logger>()
}()


// Declaration and FfiConverters for ProgressListener Callback Interface

public protocol ProgressListener : AnyObject {
    func onProgress( progress: Int32,  total: Int32 ) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceProgressListener : ForeignCallback =
    { (handle: Handle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func invokeOnProgress(_ swiftCallbackInterface: ProgressListener, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }

            let reader = Reader(data: Data(rustBuffer: args))
              swiftCallbackInterface.onProgress(
                    progress: try Int32.read(from: reader), 
                    total: try Int32.read(from: reader) 
                    )
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

    }
    

        let cb = try! ffiConverterCallbackInterfaceProgressListener.lift(handle)
        switch method {
            case IDX_CALLBACK_FREE:
                ffiConverterCallbackInterfaceProgressListener.drop(handle: handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 0
            case 1:
                let buffer = try! invokeOnProgress(cb, args)
                out_buf.pointee = buffer
                // Value written to out buffer.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 1
            
            // This should never happen, because an out of bounds method index won't
            // ever be used. Once we can catch errors, we should return an InternalError.
            // https://github.com/mozilla/uniffi-rs/issues/351
            default:
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return -1
        }
    }

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
private let ffiConverterCallbackInterfaceProgressListener: FfiConverterCallbackInterface<ProgressListener> = {
    try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            ffi_olm_c9b9_ProgressListener_init_callback(foreignCallbackCallbackInterfaceProgressListener, err)
    }
    return FfiConverterCallbackInterface<ProgressListener>()
}()
extension UInt8: Primitive, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Self {
        return try self.lift(buf.readInt())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeInt(self.lower())
    }
}
extension UInt32: Primitive, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Self {
        return try self.lift(buf.readInt())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeInt(self.lower())
    }
}
extension Int32: Primitive, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Self {
        return try self.lift(buf.readInt())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeInt(self.lower())
    }
}
extension Int64: Primitive, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Self {
        return try self.lift(buf.readInt())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeInt(self.lower())
    }
}
extension Bool: ViaFfi {
    fileprivate typealias FfiType = Int8

    fileprivate static func read(from buf: Reader) throws -> Self {
        return try self.lift(buf.readInt())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeInt(self.lower())
    }

    fileprivate static func lift(_ v: FfiType) throws -> Self {
        return v != 0
    }

    fileprivate func lower() -> FfiType {
        return self ? 1 : 0
    }
}
extension String: ViaFfi {
    fileprivate typealias FfiType = RustBuffer

    fileprivate static func lift(_ v: FfiType) throws -> Self {
        defer {
            v.deallocate()
        }
        if v.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: v.data!, count: Int(v.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    fileprivate func lower() -> FfiType {
        return self.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    fileprivate static func read(from buf: Reader) throws -> Self {
        let len: Int32 = try buf.readInt()
        return String(bytes: try buf.readBytes(count: Int(len)), encoding: String.Encoding.utf8)!
    }

    fileprivate func write(into buf: Writer) {
        let len = Int32(self.utf8.count)
        buf.writeInt(len)
        buf.writeBytes(self.utf8)
    }
}
// Helper code for BackupKeys class is found in ObjectTemplate.swift
// Helper code for BackupRecoveryKey class is found in ObjectTemplate.swift
// Helper code for OlmMachine class is found in ObjectTemplate.swift
// Helper code for BootstrapCrossSigningResult record is found in RecordTemplate.swift
// Helper code for CancelInfo record is found in RecordTemplate.swift
// Helper code for ConfirmVerificationResult record is found in RecordTemplate.swift
// Helper code for CrossSigningKeyExport record is found in RecordTemplate.swift
// Helper code for CrossSigningStatus record is found in RecordTemplate.swift
// Helper code for DecryptedEvent record is found in RecordTemplate.swift
// Helper code for Device record is found in RecordTemplate.swift
// Helper code for DeviceLists record is found in RecordTemplate.swift
// Helper code for KeyRequestPair record is found in RecordTemplate.swift
// Helper code for KeysImportResult record is found in RecordTemplate.swift
// Helper code for MegolmV1BackupKey record is found in RecordTemplate.swift
// Helper code for MigrationData record is found in RecordTemplate.swift
// Helper code for PassphraseInfo record is found in RecordTemplate.swift
// Helper code for PickledAccount record is found in RecordTemplate.swift
// Helper code for PickledInboundGroupSession record is found in RecordTemplate.swift
// Helper code for PickledSession record is found in RecordTemplate.swift
// Helper code for QrCode record is found in RecordTemplate.swift
// Helper code for RequestVerificationResult record is found in RecordTemplate.swift
// Helper code for RoomKeyCounts record is found in RecordTemplate.swift
// Helper code for Sas record is found in RecordTemplate.swift
// Helper code for ScanResult record is found in RecordTemplate.swift
// Helper code for SignatureUploadRequest record is found in RecordTemplate.swift
// Helper code for StartSasResult record is found in RecordTemplate.swift
// Helper code for UploadSigningKeysRequest record is found in RecordTemplate.swift
// Helper code for VerificationRequest record is found in RecordTemplate.swift
// Helper code for OutgoingVerificationRequest enum is found in EnumTemplate.swift
// Helper code for Request enum is found in EnumTemplate.swift
// Helper code for RequestType enum is found in EnumTemplate.swift
// Helper code for UserIdentity enum is found in EnumTemplate.swift
// Helper code for Verification enum is found in EnumTemplate.swift
// Helper code for CryptoStoreError error is found in ErrorTemplate.swift
// Helper code for DecodeError error is found in ErrorTemplate.swift
// Helper code for DecryptionError error is found in ErrorTemplate.swift
// Helper code for KeyImportError error is found in ErrorTemplate.swift
// Helper code for MigrationError error is found in ErrorTemplate.swift
// Helper code for PkDecryptionError error is found in ErrorTemplate.swift
// Helper code for SecretImportError error is found in ErrorTemplate.swift
// Helper code for SignatureError error is found in ErrorTemplate.swift

fileprivate enum FfiConverterOptionString: FfiConverterUsingByteBuffer {
    typealias SwiftType = String?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try String.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterOptionObjectBackupKeys: FfiConverterUsingByteBuffer {
    typealias SwiftType = BackupKeys?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try BackupKeys.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterOptionObjectBackupRecoveryKey: FfiConverterUsingByteBuffer {
    typealias SwiftType = BackupRecoveryKey?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try BackupRecoveryKey.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterOptionRecordCancelInfo: FfiConverterUsingByteBuffer {
    typealias SwiftType = CancelInfo?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try CancelInfo.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterOptionRecordConfirmVerificationResult: FfiConverterUsingByteBuffer {
    typealias SwiftType = ConfirmVerificationResult?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try ConfirmVerificationResult.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterOptionRecordCrossSigningKeyExport: FfiConverterUsingByteBuffer {
    typealias SwiftType = CrossSigningKeyExport?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try CrossSigningKeyExport.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterOptionRecordDevice: FfiConverterUsingByteBuffer {
    typealias SwiftType = Device?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try Device.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterOptionRecordPassphraseInfo: FfiConverterUsingByteBuffer {
    typealias SwiftType = PassphraseInfo?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try PassphraseInfo.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterOptionRecordQrCode: FfiConverterUsingByteBuffer {
    typealias SwiftType = QrCode?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try QrCode.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterOptionRecordRequestVerificationResult: FfiConverterUsingByteBuffer {
    typealias SwiftType = RequestVerificationResult?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try RequestVerificationResult.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterOptionRecordScanResult: FfiConverterUsingByteBuffer {
    typealias SwiftType = ScanResult?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try ScanResult.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterOptionRecordSignatureUploadRequest: FfiConverterUsingByteBuffer {
    typealias SwiftType = SignatureUploadRequest?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try SignatureUploadRequest.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterOptionRecordStartSasResult: FfiConverterUsingByteBuffer {
    typealias SwiftType = StartSasResult?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try StartSasResult.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterOptionRecordVerificationRequest: FfiConverterUsingByteBuffer {
    typealias SwiftType = VerificationRequest?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try VerificationRequest.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterOptionEnumOutgoingVerificationRequest: FfiConverterUsingByteBuffer {
    typealias SwiftType = OutgoingVerificationRequest?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try OutgoingVerificationRequest.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterOptionEnumRequest: FfiConverterUsingByteBuffer {
    typealias SwiftType = Request?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try Request.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterOptionEnumUserIdentity: FfiConverterUsingByteBuffer {
    typealias SwiftType = UserIdentity?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try UserIdentity.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterOptionEnumVerification: FfiConverterUsingByteBuffer {
    typealias SwiftType = Verification?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try Verification.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterOptionSequenceInt32: FfiConverterUsingByteBuffer {
    typealias SwiftType = [Int32]?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            FfiConverterSequenceInt32.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try FfiConverterSequenceInt32.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterOptionSequenceString: FfiConverterUsingByteBuffer {
    typealias SwiftType = [String]?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            FfiConverterSequenceString.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try FfiConverterSequenceString.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterSequenceUInt8: FfiConverterUsingByteBuffer {
    typealias SwiftType = [UInt8]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { (item, buf) in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try UInt8.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterSequenceInt32: FfiConverterUsingByteBuffer {
    typealias SwiftType = [Int32]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { (item, buf) in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try Int32.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterSequenceString: FfiConverterUsingByteBuffer {
    typealias SwiftType = [String]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { (item, buf) in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try String.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterSequenceRecordDevice: FfiConverterUsingByteBuffer {
    typealias SwiftType = [Device]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { (item, buf) in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try Device.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterSequenceRecordPickledInboundGroupSession: FfiConverterUsingByteBuffer {
    typealias SwiftType = [PickledInboundGroupSession]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { (item, buf) in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try PickledInboundGroupSession.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterSequenceRecordPickledSession: FfiConverterUsingByteBuffer {
    typealias SwiftType = [PickledSession]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { (item, buf) in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try PickledSession.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterSequenceRecordVerificationRequest: FfiConverterUsingByteBuffer {
    typealias SwiftType = [VerificationRequest]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { (item, buf) in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try VerificationRequest.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterSequenceEnumOutgoingVerificationRequest: FfiConverterUsingByteBuffer {
    typealias SwiftType = [OutgoingVerificationRequest]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { (item, buf) in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try OutgoingVerificationRequest.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterSequenceEnumRequest: FfiConverterUsingByteBuffer {
    typealias SwiftType = [Request]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { (item, buf) in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try Request.read(from: buf)
        }
    }
}

fileprivate enum FfiConverterDictionaryInt32: FfiConverterUsingByteBuffer {
    typealias SwiftType = [String: Int32]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterDictionary.write(value, into: buf) { (key, value, buf) in
            key.write(into: buf)
            value.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterDictionary.read(from: buf) { buf in
            (try String.read(from: buf),
            try Int32.read(from: buf))
        }
    }
}

fileprivate enum FfiConverterDictionaryString: FfiConverterUsingByteBuffer {
    typealias SwiftType = [String: String]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterDictionary.write(value, into: buf) { (key, value, buf) in
            key.write(into: buf)
            value.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterDictionary.read(from: buf) { buf in
            (try String.read(from: buf),
            try String.read(from: buf))
        }
    }
}

fileprivate enum FfiConverterDictionarySequenceString: FfiConverterUsingByteBuffer {
    typealias SwiftType = [String: [String]]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterDictionary.write(value, into: buf) { (key, value, buf) in
            key.write(into: buf)
            FfiConverterSequenceString.write(value, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterDictionary.read(from: buf) { buf in
            (try String.read(from: buf),
            try FfiConverterSequenceString.read(from: buf))
        }
    }
}

fileprivate enum FfiConverterDictionaryDictionaryString: FfiConverterUsingByteBuffer {
    typealias SwiftType = [String: [String: String]]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterDictionary.write(value, into: buf) { (key, value, buf) in
            key.write(into: buf)
            FfiConverterDictionaryString.write(value, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterDictionary.read(from: buf) { buf in
            (try String.read(from: buf),
            try FfiConverterDictionaryString.read(from: buf))
        }
    }
}

fileprivate enum FfiConverterDictionaryDictionarySequenceString: FfiConverterUsingByteBuffer {
    typealias SwiftType = [String: [String: [String]]]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterDictionary.write(value, into: buf) { (key, value, buf) in
            key.write(into: buf)
            FfiConverterDictionarySequenceString.write(value, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterDictionary.read(from: buf) { buf in
            (try String.read(from: buf),
            try FfiConverterDictionarySequenceString.read(from: buf))
        }
    }
}


/**
 * Top level initializers and tear down methods.
 *
 * This is generated by uniffi.
 */
public enum MatrixSdkCryptoLifecycle {
    /**
     * Initialize the FFI and Rust library. This should be only called once per application.
     */
    func initialize() {
        
        // No initialization code needed
        
    }
}